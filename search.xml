<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python多进程处理数据</title>
      <link href="/2023/04/25/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/25/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程、多进程"><a href="#多线程、多进程" class="headerlink" title="多线程、多进程"></a>多线程、多进程</h1><p>进程(multiprocess)是操作系统资源分配（内存，显卡，磁盘）的最小单位，线程(Thread)是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程），一个进程可以有一个或多个线程，线程之间共享进程的资源。</p><p>cpu物理核数实际上是可以同时并行的线程数量，由于超线程技术，部分cpu实际上可以并行的线程数量通常是物理核数的两倍，这也是操作系统看到的核数。</p><p>处理任务可以分为计算密集型和IO密集型，假设使用一个进程来完成这个任务，对计算密集型任务，可以使用【<strong style="color:#00b050;">核心数</strong>】个线程，就可以占满cpu资源，进而可以充分利用cpu，如果再多，就会造成额外的开销；对于IO密集型任务（涉及到网络、磁盘IO的任务都是IO密集型任务），线程由于被IO阻塞，如果仍然用【核心数】个线程，cpu是跑不满的，于是可以使用<strong style="color:#00b050;">更多个线程</strong>来提高cpu使用率。</p><h1 id="python中的并行"><a href="#python中的并行" class="headerlink" title="python中的并行"></a>python中的并行</h1><p>对于其他语言，多核CPU支持多个线程同时执行。但在Python中，无论是单核还是多核cpu，一个进程同一时间只能由一个线程在执行。其根源是 <strong style="color:#00b050;">GIL（Global Interpreter Lock 全局解释器锁)</strong> 的存在。</p><p>设计原因：多线程会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，特别容易造成变量值的混乱，所以通过线程锁来限制线程的执行，保护数据安全。某个线程想要执行，必须先拿到 GIL，在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。所以多线程在python中是行不通的。python中的并行主要指的是进程并行，</p><p>通过调用 Python 自带的多进程库 <code>Multiprocessing</code>,可以轻松的在本地电脑上进行多核并行计算</p><h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>这个模块主要有以下两个部分：</p><h2 id="multiprocess-Process"><a href="#multiprocess-Process" class="headerlink" title="multiprocess.Process"></a>multiprocess.Process</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>multiprocess.Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><ul><li>group参数未使用，值始终为None</li><li>target表示调用对象，即子进程要执行的任务</li><li>args表示调用对象的位置参数元组，args&#x3D;(1,2,’egon’,)</li><li>kwargs表示调用对象的字典，kwargs&#x3D;{‘name’:’egon’,’age’:18}</li><li>name为子进程的名称</li></ul><p>注意：</p><ol><li>需要使用关键字的方式来指定参数</li><li>args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>p.start()：启动进程，并调用该子进程中的p.run()</li><li>p.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法</li><li>p.terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive()：如果p仍然运行，返回True</li><li>p.join([timeout])：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><h2 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool()"></a>multiprocessing.Pool()</h2><p>当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p><p>Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>multiprocessing.pool.Pool(processes&#x3D;None, initializer&#x3D;None, initargs&#x3D;(), maxtasksperchild&#x3D;None, context&#x3D;None)</p><h4 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h4><ul><li>processes — 进程池中进程数量，如果为 None，则使用 os.cpu_count() 返回的值</li><li>initializer — 如果该参数不为 None，则所有进程池中的进程启动时都会先执行 initializer(*initargs)</li><li>maxtasksperchild — 如果该参数不为 None，则进程在执行 maxtasksperchild 次任务后会被自动销毁、重启</li><li>context — 用于指定进程池中进程运行的上下文</li></ul><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li><p>1、apply() — 该函数用于传递不定参数，主进程会被阻塞直到函数执行结束（不建议使用，并且3.x以后不再出现），函数原型如下：</p></li><li><p>apply(func, args&#x3D;(), kwds&#x3D;{})</p></li><li><p>2、apply_async — 与apply用法一致，但它是非阻塞的且支持结果返回后进行回调，函数原型如下：</p></li><li><p>apply_async(func[, args&#x3D;()[, kwds&#x3D;{}[, callback&#x3D;None]]])</p></li><li><p>3、map() — Pool类中的map方法，与内置的map函数用法基本一致，它会使进程阻塞直到结果返回，函数原型如下：</p></li><li><p>map(func, iterable, chunksize&#x3D;None)</p></li><li><p>注意：虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。</p></li><li><p>4、map_async() — 与map用法一致，但是它是非阻塞的。其有关事项见apply_async，函数原型如下：</p></li><li><p>map_async(func, iterable, chunksize, callback)</p></li><li><p>5、close() — 关闭进程池（pool），使其不在接受新的任务。</p></li><li><p>6、terminal() — 结束工作进程，不在处理未处理的任务。</p></li><li><p>7、join() — 主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</p></li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我主要用多进程来处理数据、画图，下面是一个基本的模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_worker</span>(<span class="params">file_paths</span>):</span><br><span class="line">    <span class="comment"># 处理文件对应的路径的数据</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data.append(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">    plt.plot(data)</span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印进程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finishing&quot;</span>,Path(file_path).name) </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义错误回调函数，如果发生错误，能将错误在主进程中打印出来       </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error_callback</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)        </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将总数据集进行分割，分割成子数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_split</span>(<span class="params">path,batch_num</span>):</span><br><span class="line">  path = <span class="built_in">list</span>(Path(path).glob(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">  <span class="comment"># 数据集长度</span></span><br><span class="line">  Len_path = <span class="built_in">len</span>(pathlist)            </span><br><span class="line">  param_dict =&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 数据分割</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_num):</span><br><span class="line">    task = <span class="string">&quot;task&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    param_dict[task] = [(pathlist[i])]</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> Len_path &gt;= batch_num:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_num,Len_path):</span><br><span class="line">      task = <span class="string">&quot;task&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(i%batch_num))</span><br><span class="line">      param_dict[task].append(pathlist[i])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> param_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_t = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 查看cpu核数</span></span><br><span class="line">    num_cores = <span class="built_in">int</span>(mp.cpu_count())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本地计算机有: &quot;</span> + <span class="built_in">str</span>(num_cores) + <span class="string">&quot; 核心&quot;</span>)</span><br><span class="line">    <span class="comment"># 开启核核数相等的进程数目</span></span><br><span class="line">    <span class="comment"># pool = mp.Pool(num_cores)    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 遍历读取当前文件夹下所有子文件夹,并且转化为列表,我这里只开启8个进程</span></span><br><span class="line">    batch_num = <span class="number">8</span></span><br><span class="line">    param_dict = task_split(Path.cwd(),batch_num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启多进程处理数据</span></span><br><span class="line">    pool = mp.Pool(batch_num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> param_dict.items():</span><br><span class="line">      pool.apply_async(single_worker, args=(param,),error_callback=error_callback)</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 关闭进程池</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    end_t = datetime.datetime.now()</span><br><span class="line">    elapsed_sec = (end_t - start_t).total_seconds()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;多进程计算 共消耗: &quot;</span> + <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(elapsed_sec) + <span class="string">&quot; 秒&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我处理10个结果，如果使用单进程需要20左右，开启8个进程，平均总时间能够减少到2s，多进程效果非常明显。</p><p>🌟注意：</p><p>必须把主进程写在「程序的入口」才能正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>这么做，能够避免重复执行主进程</p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://zhuanlan.zhihu.com/p/208996070">https://zhuanlan.zhihu.com/p/208996070</a></p><p><a href="https://zhuanlan.zhihu.com/p/103135242">https://zhuanlan.zhihu.com/p/103135242</a></p><p><a href="https://www.cnblogs.com/SkyOceanchen/p/11537587.html">https://www.cnblogs.com/SkyOceanchen/p/11537587.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/340965963">https://zhuanlan.zhihu.com/p/340965963</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> multiprocess </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python制作图片ppt</title>
      <link href="/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/"/>
      <url>/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>当需要有大量类似的图片结果需要分析的时候，一个一个插入ppt比较费时间，而且万一顺序错了就是灾难，python的Pillow库可以读取和操作图片，而python-pptx库可以创建PPT文件，非常方便。</p><h1 id="库安装"><a href="#库安装" class="headerlink" title="库安装"></a>库安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-pptx</span><br></pre></td></tr></table></figure><h1 id="单个目录"><a href="#单个目录" class="headerlink" title="单个目录"></a>单个目录</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.util <span class="keyword">import</span> Inches</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 创建一个新的PPT文件</span></span><br><span class="line">prs = Presentation()</span><br><span class="line"><span class="comment"># 图片文件夹路径</span></span><br><span class="line">img_folder = <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="comment"># 定义每页显示的图片数量</span></span><br><span class="line">pics_per_page = <span class="number">2</span></span><br><span class="line">prs = Presentation()</span><br><span class="line"><span class="comment"># 获取ppt大小</span></span><br><span class="line">width = prs.slide_width</span><br><span class="line">height = prs.slide_height</span><br><span class="line"><span class="comment"># 图片大小缩放</span></span><br><span class="line">rescale = <span class="number">1</span> </span><br><span class="line"><span class="comment"># width = Inches(6)</span></span><br><span class="line"><span class="comment"># height = Inches(4.5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹中的所有图片</span></span><br><span class="line">pic_files = <span class="built_in">sorted</span>(os.listdir(img_folder))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pic_files), pics_per_page):</span><br><span class="line">    <span class="comment"># 创建一个新的幻灯片</span></span><br><span class="line">    slide = prs.slides.add_slide(prs.slide_layouts[<span class="number">6</span>])</span><br><span class="line">    <span class="comment"># 在幻灯片中添加图片</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pics_per_page):</span><br><span class="line">        <span class="keyword">if</span> i + j &gt;= <span class="built_in">len</span>(pic_files):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 打开图片文件</span></span><br><span class="line">        img_path = os.path.join(img_folder, pic_files[i + j])</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        width_, height_ = img.size</span><br><span class="line">        <span class="comment"># 获取图片长高比例</span></span><br><span class="line">        ratio = height_ / width_</span><br><span class="line">        <span class="comment"># 计算图片在幻灯片中的位置和大小</span></span><br><span class="line">        <span class="comment"># left = Inches(j * 5)</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        top = j * height / <span class="number">2</span></span><br><span class="line">        width_rescale = width * rescale</span><br><span class="line">        height_rescale = width_rescale * ratio</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将图片添加到幻灯片中</span></span><br><span class="line">        pic = slide.shapes.add_picture(img_path, left, top, width=width_rescale, height=height_rescale)</span><br><span class="line"><span class="comment"># 保存PPT文件</span></span><br><span class="line">prs.save(<span class="string">&#x27;output.pptx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><p>这段代码首先创建了一个新的PPT文件，然后遍历指定文件夹中的所有图片文件。对于每两个图片文件，它创建一个新的幻灯片，并将两张图片添加到幻灯片中。最后，它将PPT文件保存到指定的输出文件中。请注意，这里使用了sorted()函数来确保图片按照文件名的字母顺序排序。</p><p>在幻灯片中，每张图片的宽和ppt大小保持一直，高度按照比例缩小，每张ppt上下排列两张图片，可以根据需要调整这些值。</p><p>add_picture后的四个参数分别为图片放置的左上坐标，以及宽度和高度，坐标如下：</p><p><img src="/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/image-20230424155501482.png" alt="image-20230424155501482"></p><p>参数说明：</p><p>往右，left变大，往下，top变大</p><p>🌟注意： 图片的size为像素单位，注意和Inches之间的换算</p><h1 id="多个目录"><a href="#多个目录" class="headerlink" title="多个目录"></a>多个目录</h1><p>如果有多个目录，每个文件夹下面的图片单独保存到ppt中也非常简单，只需要再嵌套一层for循环，这里我使用了pathlib库<a href="https://zhuanlan.zhihu.com/p/139783331/">教程</a> ，操作路径比os库方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.util <span class="keyword">import</span> Inches</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片文件夹路径</span></span><br><span class="line">path= Path(<span class="string">&#x27;testFlag&#x27;</span>)</span><br><span class="line"><span class="comment"># 匹配子路径</span></span><br><span class="line">pathlists = <span class="built_in">list</span>(path.glob(<span class="string">&quot;Loop*&quot;</span>))</span><br><span class="line"><span class="comment"># 确认路径</span></span><br><span class="line">pprint(pathlists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img_folder <span class="keyword">in</span> pathlists:</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 创建一个新的PPT文件</span></span><br><span class="line">  prs = Presentation()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定义每页显示的图片数量</span></span><br><span class="line">  pics_per_page = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  prs = Presentation()</span><br><span class="line">  width = prs.slide_width</span><br><span class="line">  height = prs.slide_height</span><br><span class="line">  rescale = <span class="number">1</span> </span><br><span class="line">  <span class="comment"># width = Inches(6)</span></span><br><span class="line">  <span class="comment"># height = Inches(4.5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 遍历文件夹中的所有图片</span></span><br><span class="line">  pic_files = <span class="built_in">sorted</span>(img_folder.glob(<span class="string">&quot;*&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pic_files), pics_per_page):</span><br><span class="line">      <span class="comment"># 创建一个新的幻灯片</span></span><br><span class="line">      slide = prs.slides.add_slide(prs.slide_layouts[<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 在幻灯片中添加图片</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pics_per_page):</span><br><span class="line">          <span class="keyword">if</span> i + j &gt;= <span class="built_in">len</span>(pic_files):</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 打开图片文件</span></span><br><span class="line">          img_path = os.path.join(img_folder, pic_files[i + j])</span><br><span class="line">          img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">          width_, height_ = img.size</span><br><span class="line">          ratio = height_ / width_</span><br><span class="line"></span><br><span class="line">          <span class="comment"># 计算图片在幻灯片中的位置和大小</span></span><br><span class="line">          <span class="comment"># left = Inches(j * 5)</span></span><br><span class="line">          left = <span class="number">0</span></span><br><span class="line">          top = j * height / <span class="number">2</span> + Inches(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">          width_rescale = width * rescale</span><br><span class="line">          height_rescale = width_rescale * ratio</span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 将图片添加到幻灯片中</span></span><br><span class="line">          pic = slide.shapes.add_picture(img_path, left, top, width=width_rescale, height=height_rescale)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 保存PPT文件</span></span><br><span class="line">  prs.save(img_folder.parent.joinpath(img_folder.name +<span class="string">&quot;.pptx&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装onedrive</title>
      <link href="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/"/>
      <url>/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>onedrive作为一个能跨平台的云盘，使用起来特别香，最近还增加了增量备份、查看历史版本等功能，特别适合有多个设备、需要频繁传输数据的使用者。</p><p>我经常需要在Linux平台保存数据，将处理的结果传输到win平台上，所以在服务器上也安装了OneDrive，主要的原理是磁盘挂载，相当于起到“扩大”磁盘空间的作用。</p><p>以contos7为例，仓库链接：<a href="https://github.com/skilion/onedrive">onedrive</a></p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>需要的依赖：libcurl-devel，sqlite-devel, 编译工具dmd</p><p>如果有root权限，可以直接通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libcurl-devel</span><br><span class="line">sudo yum install sqlite-devel</span><br></pre></td></tr></table></figure><p>如果没有root权限，通过下载源代码编译，不过需要把这些动态库的路径添加到bashrc里面，具体可以参考<a href="https://www.jianshu.com/p/da92ca36a220/">无root权限下解决编译时的依赖问题</a> ：</p><p>安装有先后</p><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.0.2m.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2m.tar.gz &amp;&amp; cd openssl-1.0.2m</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加shared生成动态库</span></span><br><span class="line">./config --prefix=$HOME/usr shared</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">卸载使用 make clean</span><br></pre></td></tr></table></figure><h2 id="libssh2"><a href="#libssh2" class="headerlink" title="libssh2"></a>libssh2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.libssh2.org/download/libssh2-1.8.0.tar.gz</span><br><span class="line">tar -zxvf libssh2-1.8.0.tar.gz &amp;&amp; cd libssh2-1.8.0</span><br><span class="line">./configure --with-libssl-prefix=$HOME/usr/ssl --prefix=$HOME/usr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="libcurl"><a href="#libcurl" class="headerlink" title="libcurl"></a>libcurl</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://curl.haxx.se/download/curl-7.56.1.tar.gz</span><br><span class="line">tar -zxvf curl-7.56.1.tar.gz &amp;&amp; cd curl-7.56.1</span><br><span class="line">./configure --prefix=$HOME/usr --enable-http  --enable-https --enable-ftp --enable-file --enable-proxy --enable-telnet --enable-libcurl-option --enable-ipv6 --with-lib --with-ssl</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装成功后记得把路径加入到环境变量，</p><p>将以上内容加入到.bashrc中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PAHT=$LD_LIBRARY_PATH:$HOME/usr/lib64</span><br><span class="line">export LD_LIBRARY_PAHT=$LD_LIBRARY_PATH:$HOME/usr/lib</span><br><span class="line">export PKG_CONFIG_PATH=$HOME/usr/lib/pkgconfig:$HOME/usr/share/pkgconfig</span><br><span class="line">export PATH=$HOME/usr/bin:$PATH</span><br></pre></td></tr></table></figure><p>使设置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="最后安装dlang"><a href="#最后安装dlang" class="headerlink" title="最后安装dlang"></a>最后安装dlang</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlang.org/install.sh </span><br><span class="line">bash install.sh install dmd-2.080.0</span><br></pre></td></tr></table></figure><p>我安装的版本是dmd-2.080.0，安装最新的程序后面会报错</p><p>安装成功后：</p><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_1.8ec48fc8.png"></p><p>使用 <code>source ~/dlang/dmd-2.080.0/activate</code> 命令可进入环境</p><p>注意：onedrive安装过程在进入环境后才进行的，安装完再退出环境。</p><h1 id="安装onedrive"><a href="#安装onedrive" class="headerlink" title="安装onedrive"></a>安装onedrive</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/abraunegg/onedrive/archive/refs/tags/v2.3.4.tar.gz</span><br><span class="line">tar zxvf v2.3.4.tar.gz</span><br><span class="line">cd onedrive-2.3.4/</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>由于不是使用root命令安装, 所以需要修改makefile.in</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim makefile.in</span><br></pre></td></tr></table></figure><ol><li>加入日志文件路径</li></ol><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_2.49f672c6.png"></p><ol start="2"><li>更改用户</li></ol><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_3.1df847f1.png"></p><p>将此处的 -o root -g users 改成 -o 用户名，删除后面的-g users</p><p>并且将下一行的onedrive 后面的${DESDIR}删除</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=$HOME/usr &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完，用deactivate 退出环境</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>现在您需要向 Microsoft 授权 Onedrive，以便它可以访问您的帐户。在终端中输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_4.c5e19314.png"></p><p>它会提示您访问该 URL 以获得授权。</p><p>复制此链接，在windows浏览器中打开，您将看到一个空白页面。复制 URL 并在提示符下将其粘贴到终端中。</p><p>登录您的 OneDrive 帐户，并复制此处的链接粘贴到终端。</p><p>完成以上步骤后，Onedrive 将开始将云中的所有文件下载到本地文件夹。</p><h2 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h2><p>您可以在 Onedrive git 文件夹中找到“config”文件。要激活，请将其移至 ~&#x2F;.config&#x2F;onedrive&#x2F;文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive/</span><br><span class="line">cp ~/onedrive/config ~/.config/onedrive/</span><br></pre></td></tr></table></figure><p>打开配置文件。您可以配置两个选项：“sync_dir”和“skip_files”。</p><p>sync_dir：存储 OneDrive 文件的位置。放置在此文件夹中&#x2F;从中删除的所有文件，都将同步到云端。</p><p>skip_files：不同步的文件类型（或文件模式）。</p><p>完成更改后，保存并重新启动 Onedrive。</p><p>具体配置请参考<a href="https://www.jianshu.com/p/017aa8ceef02/">linux onedrive配置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的matplotlib安装arial字体</title>
      <link href="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/"/>
      <url>/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>绘图中经常会使用Arial字体，linux服务器上默认是没有这个字体。为了省去每次修改字体的麻烦，在matplotlib中安装了这个字体，并且设置为matplotlib默认字体。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="复制字体至-matplotlib-库-fonts-x2F-ttf-目录"><a href="#复制字体至-matplotlib-库-fonts-x2F-ttf-目录" class="headerlink" title="复制字体至 matplotlib 库 fonts&#x2F;ttf 目录"></a>复制字体至 matplotlib 库 fonts&#x2F;ttf 目录</h2><p>windows上有Arial字体，在C:\Windows\Fonts 路径下，</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image_1.b2ef3533.png"></p><p>找到并且全部复制到linux服务器上matplotlib字体库下面，</p><p>路径为：python_envs_name &#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;fonts&#x2F;ttf</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image-20230423165253522.png" alt="image-20230423165253522"></p><h2 id="修改-matplotlib-库配置文件-matplotlibrc"><a href="#修改-matplotlib-库配置文件-matplotlibrc" class="headerlink" title="修改 matplotlib 库配置文件 matplotlibrc"></a>修改 matplotlib 库配置文件 matplotlibrc</h2><p>路径：env_name&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;matplotlibrc</p><p>打开后查找 font.family，将Arial加到最前面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.serif: Arial, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.sans-serif: Arial,DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.cursive: Apple Chancery, Textile, Zapf Chancery, Sand, Script MT, Felipa, Comic Neue, Comic Sans MS, cursive</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.fantasy: Chicago, Charcoal, Impact, Western, Humor Sans, xkcd, fantasy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.monospace: DejaVu Sans Mono, Bitstream Vera Sans Mono, Computer Modern Typewriter, Andale Mono, Nimbus Mono L, Courier New, Courier, Fixed, Terminal, monospace</span></span><br></pre></td></tr></table></figure><h2 id="清除-matplotlib-cache"><a href="#清除-matplotlib-cache" class="headerlink" title="清除 matplotlib cache"></a>清除 matplotlib cache</h2><p>需要清除原来的matplotlib缓存修改的字体才会生效，最直接的办法就是把缓存文件夹直接删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/User/.cache/matplotlib</span><br></pre></td></tr></table></figure><h1 id="字体说明"><a href="#字体说明" class="headerlink" title="字体说明"></a>字体说明</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">font.family : sans-serif</span><br><span class="line"></span><br><span class="line">font.sans-serif : SimHei</span><br><span class="line"></span><br><span class="line">axes.unicode_minus : <span class="literal">False</span></span><br></pre></td></tr></table></figure><ol><li><p><strong style="color:#00b0f0;">sans-serif</strong>：专指西文中无衬线的字体，与汉字字体中的黑体相对应。该类字体通常是机械的和统一线条的，它们往往拥有相同的曲率，笔直的线条，锐利的转角。这种字体当前系统中肯定存在，所以使用这个字体一定能显示出来，所以通过会加上sans-serif来保证调用。</p><p>常见的无衬线字体有 Trebuchet MS, Tahoma, Verdana, Arial, Helvetica, 中文的幼圆、隶书等等。</p><p>font-family最后加上sans-serif，也是为了保证能够调用这个字体族里面的字体，因为大多数计算机里都有这种字体。</p></li><li><p>其他字体</p></li></ol><ul><li><p>黑体：SimHei</p></li><li><p>宋体：SimSun</p></li><li><p>微软雅黑体：Microsoft YaHei</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell远程服务器本地可视化方法</title>
      <link href="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在大多数时候，我们连接的远程服务器没有图形界面，不能支持浏览器功能，这时我们需要建立本地服务器与远程服务器的通信。</p><p>以Tensorboard的本地可视化方法为例：</p><h1 id="不推荐："><a href="#不推荐：" class="headerlink" title="不推荐："></a>不推荐：</h1><p>网上常见的方法：</p><p>在本地计算机上，打开一个新的终端窗口，并使用以下命令创建一个SSH隧道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 6006:localhost:6006 username@remote\_server\_ip</span><br></pre></td></tr></table></figure><p>其中，username是您在远程服务器上的用户名，remote_server_ip是远程服务器的IP地址。</p><p>1.在远程服务器上启动TensorBoard：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=/path/to/logs</span><br></pre></td></tr></table></figure><p>2.找到TensorBoard启动时显示的URL，类似于以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TensorBoard 1.14.0 at [http://localhost:6006/](http://localhost:6006/) (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>3.在本地计算机上，打开Web浏览器并访问以下URL：</p><p><a href="http://localhost:6006/">http://localhost:6006</a></p><p>这个方法我尝试了多次，都不成功：</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_1.44605818.png"></p><p><strong style="color:#00b050;">可能windows电脑不适用</strong></p><h1 id="推荐方法：Xshell隧道"><a href="#推荐方法：Xshell隧道" class="headerlink" title="推荐方法：Xshell隧道"></a>推荐方法：Xshell隧道</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开Xshell，右击相应的会话，在弹出的对话框中选择属性-&gt;连接-&gt;SSH-&gt;隧道-&gt;添加。</p><p>在侦听端口和目标端口中填入相同的端口，此处填写了6006;（这里的端口号，也可以随便换成其他的，只要保证两处相同即可）。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_2.73d50b2e.png"></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>服务器端启动tensorboard</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensrboard --logdir=log地址 --port=6006</span><br></pre></td></tr></table></figure><p>本地浏览器查看</p><p>然后再本地浏览器中输入：<a href="http://127.0.0.1:6006/">http://127.0.0.1:6006</a> 或者localhost:6006，可以通过tensorboard查看目前的训练情况。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_3.5e37b6bd.png"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/a314688122a/article/details/81505082">https://blog.csdn.net/a314688122a/article/details/81505082</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpirun运行参数</title>
      <link href="/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对于mpirun运行参数存在疑问，<a href="https://www.cnblogs.com/devilmaycry812839668/p/15132333.html">转载来源</a></p><p>相关资料，参看前文：</p><p><a href="https://www.cnblogs.com/devilmaycry812839668/p/15107935.html">https://www.cnblogs.com/devilmaycry812839668/p/15107935.html</a></p><p>现有硬件：两台装有Ubuntu18.04的操作系统（下面简称A电脑，B电脑）</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>网络：</p><p>A、B电脑之间使用100M以太网交换机连接（就是TP-Link路由器）。</p><p>其中，A电脑IP为 192.168.11.66， B电脑IP为 192.168.11.206</p><p>本文中的代码   x.py  :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">size = comm.Get_size()</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line"> </span><br><span class="line">sendbuf = np.zeros(<span class="number">100</span>*<span class="number">10000</span>, dtype=<span class="string">&#x27;i&#x27;</span>) + rank</span><br><span class="line">recvbuf = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    recvbuf = np.empty([size, <span class="number">100</span>*<span class="number">10000</span>], dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( MPI.Get_processor_name() )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">a = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    comm.Gather(sendbuf, recvbuf, root=<span class="number">0</span>)</span><br><span class="line">b = time.time()</span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(b-a)</span><br></pre></td></tr></table></figure><p>本文所有的命令均为在主机A上执行，所以本文中对myhosts文件的编写都是在A主机下进行的。</p><h1 id="参数-–machinefile"><a href="#参数-–machinefile" class="headerlink" title="参数   –machinefile"></a>参数   –machinefile</h1><p>该参数主要是用在分布式环境下，在单机环境该参数没有意义。该参数就是指定分布式环境下有几台主机，并且可以指定每台主机最多可以开几个CPU进行计算。</p><p>具体命令:</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxx/anaconda3/bin/python x.py</code></p><p>其中， myhosts 为我们需要编写的文本文件，该文件指定mpi分布式环境下各个主机的IP及可以运行的最多CPU数。</p><p>myhosts文件最基本的设置就是不指定每个主机最多可以运行的CPU数，那么此时每台主机最多可以运行的CPU数为多少呢，这时每台主机最多可以运行的CPU数为该主机的物理CPU核心数，本文中主机A 192.168.11.66的最多可以运行CPU数为24， 主机B 192.168.11.206最多可以运行的CPU数为6。</p><p>最基本的 myhosts ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       </span><br><span class="line">192.168.11.206 </span><br></pre></td></tr></table></figure><p>myhosts中给出分布式环境下两个主机IP，此时每个主机最多可以使用的CPU数为物理核心个数。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示8个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，&#x3D;&#x3D;所有优先使用主机A的计算资源&#x3D;&#x3D;）。</p><p>执行命令：</p><p>`mpirun -np 24 –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果显示24个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>执行命令：</p><p><code>mpirun -np 25  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行25个进程，其中24个进程运行在主机A上， 一个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有一个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 30  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行30个进程，其中24个进程运行在主机A上， 6个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有6个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 31  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the <span class="number">31</span></span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/<span class="built_in">bin</span>/python</span><br><span class="line">Either request fewer slots foryour application, <span class="keyword">or</span> make more slots</span><br><span class="line">available <span class="keyword">for</span> use.</span><br><span class="line">A <span class="string">&quot;slot&quot;</span>isthe Open MPI term <span class="keyword">for</span> an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment <span class="keyword">in</span> which Open MPI processes are run:</span><br><span class="line"><span class="number">1.</span> Hostfile, via <span class="string">&quot;slots=N&quot;</span> clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  <span class="number">2.</span> The --host command line parameter, via a <span class="string">&quot;:N&quot;</span> suffix on the</span><br><span class="line">     hostname (N defaults to <span class="number">1</span> ifnot provided)</span><br><span class="line">  <span class="number">3.</span> Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  <span class="number">4.</span> If none of a hostfile, the --host command line parameter, <span class="keyword">or</span> an</span><br><span class="line">     RM <span class="keyword">is</span> present, Open MPI defaults to the number of processor cores</span><br><span class="line">In <span class="built_in">all</span> the above cases, <span class="keyword">if</span> you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机最多运行24个CPU，B主机最多运行6个CPU，所以当前系统下最多可以运行的CPU个数为30，超出这个个数则会报错。</p><h1 id="参数-slots"><a href="#参数-slots" class="headerlink" title="参数  slots"></a>参数  slots</h1><p>进阶版的myhosts的编写，指定每个主机最多可以使用的CPU个数，这个CPU个数最好是小于指定主机的物理核心数，否则该设定没有意义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>指定主机A 、B中每个主机最多可以使用cpu个数均为4，其中每个主机IP（或主机名）后面的的slots的数值可以自由设定，不过只能小于等于该主机的物理核心数。</p><p>执行命令：</p><p><code>mpirun -np 4  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上。</p><p>执行命令：</p><p><code>mpirun -np 6  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，2个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，4个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 9  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are not enough slots available in the system to satisfy the 31</span><br><span class="line">slots that were requested by the application:</span><br><span class="line"></span><br><span class="line">  /home/xxxxxx/anaconda3/bin/python</span><br><span class="line"></span><br><span class="line">Either request fewer slots for your application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line"></span><br><span class="line">A &quot;slot&quot; is the Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line"></span><br><span class="line">  1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores if not provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 if not provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line"></span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line"></span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机我们指定最多运行4个CPU，B主机最多运行4个CPU，所以当前系统下最多可以运行的CPU个数为8，超出这个个数则会报错。</p><h1 id="参数-np-："><a href="#参数-np-：" class="headerlink" title="参数 -np ："></a>参数 -np ：</h1><p>如果我们运行时不使用 -np 参数， 那么运行情节如何呢：</p><p>在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66</span><br><span class="line">192.168.11.206</span><br></pre></td></tr></table></figure><p>运行命令:</p><p>`mpirun –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果，A主机运行24个进程，B主机运行6个进程，也就是说不指定 -np参数 &#x3D;&#x3D;每个主机都是以全部的物理核心来运行进程。&#x3D;&#x3D;</p><p>如果在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>运行命令:</p><p><code>mpirun --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果，A主机运行4个进程，B主机运行4个进程，也就是说不指定 -np参数 和之前一样每个主机都是以全部的可以运行的CPU个数来运行进程。（因为这里在myhosts文件中使用了slots参数已经设定了A主机最多可以使用4个CPU，B主机最多可以使用4个CPU）</p><h1 id="参数-nolocal"><a href="#参数-nolocal" class="headerlink" title="参数  -nolocal"></a>参数  -nolocal</h1><p>在执行mpi命令时加入参数 -nolocal 则指定不运行当前所在主机上的CPU，具体：</p><p>假设myhosts文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>myhosts 文件指定A、B主机均只能最多使用4个CPU。</p><p>在主机A 192.168.11.66 上运行命令：</p><p>`mpirun -nolocal –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the 8</span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/bin/python</span><br><span class="line">Either request fewer slots foryour application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line">A &quot;slot&quot;isthe Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line">1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 ifnot provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>也就是说 -nolocal 不允许本地主机A参与计算，而 myhosts文件中又允许A主机参与计算，因此造成冲突。在没有使用 -np 参数的情况下是需要使用myhosts文件中指定的CPU数的最大值来运行的，但是-nolocal不允许A主机参与运行无法满足myhosts文件中的8个CPU的设定，因此报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 6  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>依旧报错误：</p><p><code>There are notenough slots available inthe system to satisfy the 6 slots that were requested by the application:</code></p><p>原因是不使用本地主机A的情况下 -np 指定需要6个CPU运行，但是myhosts中指定B主机192.168.11.206最多可以运行4个CPU，因此不满足6个CPU运行的要求报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 4  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。四个进程全部运行在B主机192.168.11.206 上。既满足 -np 4 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><p>同理：</p><p>上面的运行语句中改进下，如下：</p><p><code> mpirun -np 2  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。2个进程全部运行在B主机192.168.11.206 上。既满足 -np 2 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><h1 id="参数-–use-hwthread-cpus-与-–oversubscribe"><a href="#参数-–use-hwthread-cpus-与-–oversubscribe" class="headerlink" title="参数  –use-hwthread-cpus  与  –oversubscribe"></a>参数  –use-hwthread-cpus  与  –oversubscribe</h1><p>前面我们知道 A、B主机的CPU物理核心个数：</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>&#x3D;&#x3D;-np 指定该次运行一共需要的CPU个数&#x3D;&#x3D;，-nolocal 指定不使用当前主机的CPU进行运算，myhosts中指定参与计算的各主机的最多参与计算的CPU个数。</p><p>正如我们前面所说的，myhosts文件中虽然可以指定每个主机最多可以使用的CPU个数，但是这个个数是我们人为设定的，设定的一个要求就是要小于主机的物理核心个数。如果myhosts 中slots指定的CPU数量等于主机物理核心个数那么slots本身是没有意义的，因为myhosts中不使用slots设定所能使用的最多CPU个数也是该主机的物理核心个数。</p><p>那么 myhosts 中slots的个数设定真的不能大于主机的物理核心数，其实不然。之所以我们默认要求slots个数不能大于物理核心数是因为在<strong>独占</strong>主机进行<strong>计算密集型</strong>运算时当主机上运行的进程数等于物理核心数时往往会得到最高的利用率。</p><p>一个隐藏知识，根据Intel cpu的白皮书（蓝皮书）可以看到在使用超流水线多线程运算时密集计算型计算性能可以提高30%，这就是说在Intel超流水线技术支持下，密集计算任务单主机下进程数等于逻辑核心个数其性能要&#x3D;&#x3D;超进程数等于物理核心数&#x3D;&#x3D;时的30%，不过这只是在短时间计算情景下，如果在长时间运行情况下当进程数等于逻辑核心数时计算密集型任务往往会导致CPU的散热撞到功率墙（散热墙）从而导致大幅度CPU降频，从而导致计算性能大幅下降，当然这说的是普通散热情况下，因此在进行计算密集型计算任务时我们都是默认设定进程数等于物理核心数。</p><p>也就是说，如果我们在 myhosts 文件中设定 slots 个数超过主机的物理核心数在不考虑计算性能的情况下是完全可行的。</p><p>给出此时的myhosts内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=100</span><br><span class="line">192.168.11.206      slots=100</span><br></pre></td></tr></table></figure><p>运行语句中如下：</p><p><code>mpirun -np 200  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。共运行200个进程，其中100个进程运行在A主机192.168.11.66 上， 100个进程运行在B主机192.168.11.206 上。</p><p>由此可见使用 myhosts文件中的slots设定也是可以运行超过物理核心数的进程的。</p><p>刚才说的是在使用 –machinefile 参数 利用myhosts 文件中的设定来实现超过物理核心数的进程数量运行的，如果我们不使用 –machinefile 参数的情况下呢？？？</p><h1 id="参数-–host"><a href="#参数-–host" class="headerlink" title="参数 –host"></a>参数 –host</h1><p>执行命令：</p><p><code>mpirun -np 8  --host 192.168.11.66:4 --host 192.168.11.206:4   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行4个进程，在B主机192.168.11.206上运行4个进程，共运行8个进程。</p><p>执行命令：</p><p><code>mpirun -np 6  --host 192.168.11.206:6   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在B主机192.168.11.206上运行6个进程，共运行6个进程。</p><p>执行命令：</p><p><code>mpirun -np 200  --host 192.168.11.66:100 --host 192.168.11.206:100   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行100个进程，在B主机192.168.11.206上运行100个进程，共运行200个进程。</p><p>执行命令：</p><p><code>mpirun -np 200 --host 192.168.11.206:200   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在B主机192.168.11.206上运行200个进程，共运行200个进程。</p><p>当然上面的都是在分布式的环境下运行的（ 分布式环境下是指使用 –host 参数）。</p><p>如果不使用 –host 参数，在单机环境下如何实现超过物理核心数的进程数运行呢？？？</p><p>如：</p><p>执行命令：</p><p><code>mpirun -np 48   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>命令的含义是在A主机192.168.11.66上运行48个进程，而A主机的物理核心数为24，因此报错。</p><p>There are notenough slots available inthe system to satisfy the 48<br>slots that were requested by the application:</p><p>这时改用命令：（加入参数 –use-hwthread-cpus ）</p><p>--use-hwthread-cpus 参数的含义是允许当前主机运行的进程最大数为逻辑核心数而不是物理核心数。</p><p><code>mpirun -np 48 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在A主机192.168.11.66上运行48个进程，A主机为当前命令执行时所在的主机，其逻辑核心数为48。</p><p>改命令为：</p><p><code>mpirun -np 49 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行失败，因为 –use-hwthread-cpus 参数只能设定最多运行进程数为逻辑核心数，因此超过48后报错（A主机逻辑核心数为48）。</p><p>这时改用 参数 –oversubscribe ：</p><p>--oversubscribe 参数的含义就是不对进程数设限制，也就是说进程数可以随便设置。</p><p>执行命令如下：</p><p><code>mpirun -np 200  --oversubscribe  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66上运行了200个进程。</p><h1 id="附加内容："><a href="#附加内容：" class="headerlink" title="附加内容："></a>附加内容：</h1><p>在执行mpi程序时rank0进程是在哪个主机上呢？？？</p><p>（rank0进程就是mpi程序运行后rank排名号为0号的进程）</p><p>在主机A 192.168.11.66 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在A主机 192.168.11.66上。</p><p>同理：</p><p>在主机B 192.168.11.206 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在B主机 192.168.11.206上。</p><p>由上面的运行情况我们可以知道 rank0 进程一般都是运行在启动mpi程序并使用CPU运行进程的主机上（需要排除使用参数 -nolocal 的情况，该种情况启动mpi程序的主机是不使用CPU参与计算的，因此rank0进程此时是不在启动mpi程序的主机上的）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mpirun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-basic</title>
      <link href="/2023/04/20/vscode-basic/"/>
      <url>/2023/04/20/vscode-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>打开<a href="https://code.visualstudio.com/">Vscode</a> 官网直接下载即可</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ol><li><p>Python</p><p>Python为VSCode添加了对Python的语言支持，包括 IntelliSense 和Debugging等功能</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145247297.png" alt="image-20230420145247297"></p><ol start="2"><li><p>Jupyter</p><p>  Jupyter为VSCode添加了对Jupyter Notebook的功能支持</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145530009.png" alt="image-20230420145530009"></p><ol start="3"><li><p>Code Runner</p><p>Code Runner用于直接运行多种语言的代码片段或文件</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145551529.png" alt="image-20230420145551529"></p><ol start="4"><li><p>Better Comments</p><p>Better Comments为代码注释提供各种特定类型注释的高亮。</p></li></ol><p> <img src="/2023/04/20/vscode-basic/image-20230420145609253.png" alt="image-20230420145609253"></p><ol start="5"><li><p>Bracket Pair Colorizer</p><p>给匹配的括号着色</p></li><li><p>Indent-Rainbow</p><p>让缩进带有颜色</p></li><li><p>Path Intellisense</p><p>自动完成文件名</p></li><li><p>Prettier - Code formatter</p><p>更优雅的代码格式化,vscode 里比较优秀的一个格式化插件</p></li><li><p>matlab插件</p><p>支持自动补全、跳转定义、变量重命名 </p></li><li><p>Remote-SSH</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145707498.png" alt="image-20230420145707498"></p><ol start="11"><li><p>Markdown Preview Enhanced（markdown 预览增强）</p></li><li><p>GitHub Pull Requests and Issues</p><p>自动识别仓库变动，一键push和pull，特别方便</p><p><img src="/2023/04/20/vscode-basic/image-20230423173040299.png" alt="image-20230423173040299"></p></li><li><p>WD-TabNine</p><p>非常强大的代码自动补全工具</p></li></ol><h1 id="Remote-SSH连接"><a href="#Remote-SSH连接" class="headerlink" title="Remote-SSH连接"></a>Remote-SSH连接</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装Remote-SSHR之后，点击界面左下角的打开远程窗口</p><p><img src="/2023/04/20/vscode-basic/image-20230420145744807.png" alt="image-20230420145744807"></p><p>选择Connect to Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145758242.png" alt="image-20230420145758242"></p><p>选择Add New SSH Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145807767.png" alt="image-20230420145807767"></p><p>输入对应的用户名和远程IP地址</p><p><img src="/2023/04/20/vscode-basic/image-20230420145813675.png" alt="image-20230420145813675"></p><p>在弹出的设置配置文件路径，选择第一项</p><p><img src="/2023/04/20/vscode-basic/image-20230420145819225.png" alt="image-20230420145819225"></p><p>界面右下角显示Host added!</p><p><img src="/2023/04/20/vscode-basic/image-20230420145824770.png" alt="image-20230420145824770"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>添加host成功之后，再点击左下角的打开远程连接窗口，</p><p>  <img src="/2023/04/20/vscode-basic/image-20230420145829467.png" alt="image-20230420145829467"></p><p>就会出现刚刚配置好的host，点击，输入密码，就可以成功登录了</p><p> <img src="/2023/04/20/vscode-basic/image-20230420145837776.png" alt="image-20230420145837776"></p><h2 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h2><p>登录成功后，为了避免每次输入密码，在linux服务器上添加公钥（参考添加公钥到github）;</p><p>在远程终端上</p><p>先定位目录<br><code> cd .ssh</code></p><p>再看看有没有authorized_keys文件：<br> <code>ls</code></p><p>然后编辑它<br><code> vim authorized_keys</code></p><p>然后按i进入编辑模式<br> 然后把本机 后缀.pub文件（比如id_rsa.pub）的内容粘贴上去：<br> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPsqZlc1lASXIwrOSpyyghF+U 一大串</p><p>最后 按ESC 然后输入:wq （写入内容并quit退出）<br> 然后关闭vscode窗口自动断开链接，再按 第3步 直接点击 然后直接连接上并成功登录！</p><h1 id="使用远程服务器上的jypyter"><a href="#使用远程服务器上的jypyter" class="headerlink" title="使用远程服务器上的jypyter"></a>使用远程服务器上的jypyter</h1><h2 id="启动jupyper-服务器"><a href="#启动jupyper-服务器" class="headerlink" title="启动jupyper 服务器"></a>启动jupyper 服务器</h2><p>在终端激活对应的conda 虚拟环境之后，输入jupyter notebook，启动jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145849003.png" alt="image-20230420145849003"></p><p>复制下面的地址，两个都可以</p><p><img src="/2023/04/20/vscode-basic/image-20230420145854628.png" alt="image-20230420145854628"></p><h2 id="vscode中连接远程jupyter"><a href="#vscode中连接远程jupyter" class="headerlink" title="vscode中连接远程jupyter"></a>vscode中连接远程jupyter</h2><p>安装juyter拓展后，按快捷键打开输入框，输入jupyter以后就可以看到以下提示，选择为连接指定jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145901403.png" alt="image-20230420145901403"></p><p>之后进入以下界面，需要输入刚刚已启动的jupyter notebook的URL连接，如上的两个链接，复制输入框中按回车就可以连接服务器上的jupyter</p><p><img src="/2023/04/20/vscode-basic/image-20230420145907727.png" alt="image-20230420145907727"></p><p>此时就可以选择新建或打开远程服务器上的ipynb文件，可能会提示要为远程服务器安装python拓展，确认安装即可。</p><h2 id="切换虚拟环境"><a href="#切换虚拟环境" class="headerlink" title="切换虚拟环境"></a>切换虚拟环境</h2><p>服务器上配置有多个 <a href="https://so.csdn.net/so/search?q=conda&spm=1001.2101.3001.7020">conda</a> 虚拟环境，如果每次启动jupyter之前需要激活对应的虚拟环境，后续就不方便切换，</p><p>使用nb_conda_kernels 添加所有环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate base   # could be also some other environment</span><br><span class="line"></span><br><span class="line">conda install nb_conda_kernels</span><br><span class="line"></span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>安装好后，打开 jupyter notebook 就会显示所有的 conda 环境</p><p><img src="/2023/04/20/vscode-basic/image-20230420145917965.png" alt="image-20230420145917965"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux的matplotlib安装arial字体</title>
      <link href="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/"/>
      <url>/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>绘图中经常会使用Arial字体，linux服务器上默认是没有这个字体。为了省去每次修改字体的麻烦，在matplotlib中安装了这个字体，并且设置为matplotlib默认字体。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="复制字体至-matplotlib-库-fonts-x2F-ttf-目录"><a href="#复制字体至-matplotlib-库-fonts-x2F-ttf-目录" class="headerlink" title="复制字体至 matplotlib 库 fonts&#x2F;ttf 目录"></a>复制字体至 matplotlib 库 fonts&#x2F;ttf 目录</h2><p>windows上有Arial字体，在C:\Windows\Fonts 路径下，</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image_1.b2ef3533.png"></p><p>找到并且全部复制到linux服务器上matplotlib字体库下面，</p><p>路径为：python_envs_name &#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;fonts&#x2F;ttf</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image-20230423165253522.png" alt="image-20230423165253522"></p><h2 id="修改-matplotlib-库配置文件-matplotlibrc"><a href="#修改-matplotlib-库配置文件-matplotlibrc" class="headerlink" title="修改 matplotlib 库配置文件 matplotlibrc"></a>修改 matplotlib 库配置文件 matplotlibrc</h2><p>路径：env_name&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;matplotlibrc</p><p>打开后查找 font.family，将Arial加到最前面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.serif: Arial, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.sans-serif: Arial,DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.cursive: Apple Chancery, Textile, Zapf Chancery, Sand, Script MT, Felipa, Comic Neue, Comic Sans MS, cursive</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.fantasy: Chicago, Charcoal, Impact, Western, Humor Sans, xkcd, fantasy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.monospace: DejaVu Sans Mono, Bitstream Vera Sans Mono, Computer Modern Typewriter, Andale Mono, Nimbus Mono L, Courier New, Courier, Fixed, Terminal, monospace</span></span><br></pre></td></tr></table></figure><h2 id="清除-matplotlib-cache"><a href="#清除-matplotlib-cache" class="headerlink" title="清除 matplotlib cache"></a>清除 matplotlib cache</h2><p>需要清除原来的matplotlib缓存修改的字体才会生效，最直接的办法就是把缓存文件夹直接删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/User/.cache/matplotlib</span><br></pre></td></tr></table></figure><h1 id="字体说明"><a href="#字体说明" class="headerlink" title="字体说明"></a>字体说明</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">font.family : sans-serif</span><br><span class="line"></span><br><span class="line">font.sans-serif : SimHei</span><br><span class="line"></span><br><span class="line">axes.unicode_minus : <span class="literal">False</span></span><br></pre></td></tr></table></figure><ol><li><p><strong style="color:#00b0f0;">sans-serif</strong>：专指西文中无衬线的字体，与汉字字体中的黑体相对应。该类字体通常是机械的和统一线条的，它们往往拥有相同的曲率，笔直的线条，锐利的转角。这种字体当前系统中肯定存在，所以使用这个字体一定能显示出来，所以通过会加上sans-serif来保证调用。</p><p>常见的无衬线字体有 Trebuchet MS, Tahoma, Verdana, Arial, Helvetica, 中文的幼圆、隶书等等。</p><p>font-family最后加上sans-serif，也是为了保证能够调用这个字体族里面的字体，因为大多数计算机里都有这种字体。</p></li><li><p>其他字体</p></li></ol><ul><li><p>黑体：SimHei</p></li><li><p>宋体：SimSun</p></li><li><p>微软雅黑体：Microsoft YaHei</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python, linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell远程服务器本地可视化方法</title>
      <link href="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在大多数时候，我们连接的远程服务器没有图形界面，不能支持浏览器功能，这时我们需要建立本地服务器与远程服务器的通信。</p><p>以Tensorboard的本地可视化方法为例：</p><h1 id="不推荐："><a href="#不推荐：" class="headerlink" title="不推荐："></a>不推荐：</h1><p>网上常见的方法：</p><p>在本地计算机上，打开一个新的终端窗口，并使用以下命令创建一个SSH隧道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 6006:localhost:6006 username@remote\_server\_ip</span><br></pre></td></tr></table></figure><p>其中，username是您在远程服务器上的用户名，remote_server_ip是远程服务器的IP地址。</p><p>1.在远程服务器上启动TensorBoard：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=/path/to/logs</span><br></pre></td></tr></table></figure><p>2.找到TensorBoard启动时显示的URL，类似于以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TensorBoard 1.14.0 at [http://localhost:6006/](http://localhost:6006/) (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>3.在本地计算机上，打开Web浏览器并访问以下URL：</p><p><a href="http://localhost:6006/">http://localhost:6006</a></p><p>这个方法我尝试了多次，都不成功：</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_1.44605818.png"></p><p><strong style="color:#00b050;">可能windows电脑不适用</strong></p><h1 id="推荐方法：Xshell隧道"><a href="#推荐方法：Xshell隧道" class="headerlink" title="推荐方法：Xshell隧道"></a>推荐方法：Xshell隧道</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开Xshell，右击相应的会话，在弹出的对话框中选择属性-&gt;连接-&gt;SSH-&gt;隧道-&gt;添加。</p><p>在侦听端口和目标端口中填入相同的端口，此处填写了6006;（这里的端口号，也可以随便换成其他的，只要保证两处相同即可）。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_2.73d50b2e.png"></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>服务器端启动tensorboard</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensrboard --logdir=log地址 --port=6006</span><br></pre></td></tr></table></figure><p>本地浏览器查看</p><p>然后再本地浏览器中输入：<a href="http://127.0.0.1:6006/">http://127.0.0.1:6006</a> 或者localhost:6006，可以通过tensorboard查看目前的训练情况。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_3.5e37b6bd.png"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/a314688122a/article/details/81505082">https://blog.csdn.net/a314688122a/article/details/81505082</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpirun运行参数</title>
      <link href="/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对于mpirun运行参数存在疑问，<a href="https://www.cnblogs.com/devilmaycry812839668/p/15132333.html">转载来源</a></p><p>相关资料，参看前文：</p><p><a href="https://www.cnblogs.com/devilmaycry812839668/p/15107935.html">https://www.cnblogs.com/devilmaycry812839668/p/15107935.html</a></p><p>现有硬件：两台装有Ubuntu18.04的操作系统（下面简称A电脑，B电脑）</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>网络：</p><p>A、B电脑之间使用100M以太网交换机连接（就是TP-Link路由器）。</p><p>其中，A电脑IP为 192.168.11.66， B电脑IP为 192.168.11.206</p><p>本文中的代码   x.py  :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">size = comm.Get_size()</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line"> </span><br><span class="line">sendbuf = np.zeros(<span class="number">100</span>*<span class="number">10000</span>, dtype=<span class="string">&#x27;i&#x27;</span>) + rank</span><br><span class="line">recvbuf = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    recvbuf = np.empty([size, <span class="number">100</span>*<span class="number">10000</span>], dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( MPI.Get_processor_name() )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">a = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    comm.Gather(sendbuf, recvbuf, root=<span class="number">0</span>)</span><br><span class="line">b = time.time()</span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(b-a)</span><br></pre></td></tr></table></figure><p>本文所有的命令均为在主机A上执行，所以本文中对myhosts文件的编写都是在A主机下进行的。</p><h1 id="参数-–machinefile"><a href="#参数-–machinefile" class="headerlink" title="参数   –machinefile"></a>参数   –machinefile</h1><p>该参数主要是用在分布式环境下，在单机环境该参数没有意义。该参数就是指定分布式环境下有几台主机，并且可以指定每台主机最多可以开几个CPU进行计算。</p><p>具体命令:</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxx/anaconda3/bin/python x.py</code></p><p>其中， myhosts 为我们需要编写的文本文件，该文件指定mpi分布式环境下各个主机的IP及可以运行的最多CPU数。</p><p>myhosts文件最基本的设置就是不指定每个主机最多可以运行的CPU数，那么此时每台主机最多可以运行的CPU数为多少呢，这时每台主机最多可以运行的CPU数为该主机的物理CPU核心数，本文中主机A 192.168.11.66的最多可以运行CPU数为24， 主机B 192.168.11.206最多可以运行的CPU数为6。</p><p>最基本的 myhosts ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       </span><br><span class="line">192.168.11.206 </span><br></pre></td></tr></table></figure><p>myhosts中给出分布式环境下两个主机IP，此时每个主机最多可以使用的CPU数为物理核心个数。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示8个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，&#x3D;&#x3D;所有优先使用主机A的计算资源&#x3D;&#x3D;）。</p><p>执行命令：</p><p>`mpirun -np 24 –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果显示24个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>执行命令：</p><p><code>mpirun -np 25  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行25个进程，其中24个进程运行在主机A上， 一个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有一个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 30  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行30个进程，其中24个进程运行在主机A上， 6个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有6个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 31  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the <span class="number">31</span></span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/<span class="built_in">bin</span>/python</span><br><span class="line">Either request fewer slots foryour application, <span class="keyword">or</span> make more slots</span><br><span class="line">available <span class="keyword">for</span> use.</span><br><span class="line">A <span class="string">&quot;slot&quot;</span>isthe Open MPI term <span class="keyword">for</span> an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment <span class="keyword">in</span> which Open MPI processes are run:</span><br><span class="line"><span class="number">1.</span> Hostfile, via <span class="string">&quot;slots=N&quot;</span> clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  <span class="number">2.</span> The --host command line parameter, via a <span class="string">&quot;:N&quot;</span> suffix on the</span><br><span class="line">     hostname (N defaults to <span class="number">1</span> ifnot provided)</span><br><span class="line">  <span class="number">3.</span> Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  <span class="number">4.</span> If none of a hostfile, the --host command line parameter, <span class="keyword">or</span> an</span><br><span class="line">     RM <span class="keyword">is</span> present, Open MPI defaults to the number of processor cores</span><br><span class="line">In <span class="built_in">all</span> the above cases, <span class="keyword">if</span> you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机最多运行24个CPU，B主机最多运行6个CPU，所以当前系统下最多可以运行的CPU个数为30，超出这个个数则会报错。</p><h1 id="参数-slots"><a href="#参数-slots" class="headerlink" title="参数  slots"></a>参数  slots</h1><p>进阶版的myhosts的编写，指定每个主机最多可以使用的CPU个数，这个CPU个数最好是小于指定主机的物理核心数，否则该设定没有意义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>指定主机A 、B中每个主机最多可以使用cpu个数均为4，其中每个主机IP（或主机名）后面的的slots的数值可以自由设定，不过只能小于等于该主机的物理核心数。</p><p>执行命令：</p><p><code>mpirun -np 4  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上。</p><p>执行命令：</p><p><code>mpirun -np 6  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，2个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，4个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 9  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are not enough slots available in the system to satisfy the 31</span><br><span class="line">slots that were requested by the application:</span><br><span class="line"></span><br><span class="line">  /home/xxxxxx/anaconda3/bin/python</span><br><span class="line"></span><br><span class="line">Either request fewer slots for your application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line"></span><br><span class="line">A &quot;slot&quot; is the Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line"></span><br><span class="line">  1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores if not provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 if not provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line"></span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line"></span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机我们指定最多运行4个CPU，B主机最多运行4个CPU，所以当前系统下最多可以运行的CPU个数为8，超出这个个数则会报错。</p><h1 id="参数-np-："><a href="#参数-np-：" class="headerlink" title="参数 -np ："></a>参数 -np ：</h1><p>如果我们运行时不使用 -np 参数， 那么运行情节如何呢：</p><p>在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66</span><br><span class="line">192.168.11.206</span><br></pre></td></tr></table></figure><p>运行命令:</p><p>`mpirun –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果，A主机运行24个进程，B主机运行6个进程，也就是说不指定 -np参数 &#x3D;&#x3D;每个主机都是以全部的物理核心来运行进程。&#x3D;&#x3D;</p><p>如果在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>运行命令:</p><p><code>mpirun --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果，A主机运行4个进程，B主机运行4个进程，也就是说不指定 -np参数 和之前一样每个主机都是以全部的可以运行的CPU个数来运行进程。（因为这里在myhosts文件中使用了slots参数已经设定了A主机最多可以使用4个CPU，B主机最多可以使用4个CPU）</p><h1 id="参数-nolocal"><a href="#参数-nolocal" class="headerlink" title="参数  -nolocal"></a>参数  -nolocal</h1><p>在执行mpi命令时加入参数 -nolocal 则指定不运行当前所在主机上的CPU，具体：</p><p>假设myhosts文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>myhosts 文件指定A、B主机均只能最多使用4个CPU。</p><p>在主机A 192.168.11.66 上运行命令：</p><p>`mpirun -nolocal –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the 8</span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/bin/python</span><br><span class="line">Either request fewer slots foryour application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line">A &quot;slot&quot;isthe Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line">1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 ifnot provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>也就是说 -nolocal 不允许本地主机A参与计算，而 myhosts文件中又允许A主机参与计算，因此造成冲突。在没有使用 -np 参数的情况下是需要使用myhosts文件中指定的CPU数的最大值来运行的，但是-nolocal不允许A主机参与运行无法满足myhosts文件中的8个CPU的设定，因此报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 6  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>依旧报错误：</p><p><code>There are notenough slots available inthe system to satisfy the 6 slots that were requested by the application:</code></p><p>原因是不使用本地主机A的情况下 -np 指定需要6个CPU运行，但是myhosts中指定B主机192.168.11.206最多可以运行4个CPU，因此不满足6个CPU运行的要求报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 4  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。四个进程全部运行在B主机192.168.11.206 上。既满足 -np 4 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><p>同理：</p><p>上面的运行语句中改进下，如下：</p><p><code> mpirun -np 2  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。2个进程全部运行在B主机192.168.11.206 上。既满足 -np 2 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><h1 id="参数-–use-hwthread-cpus-与-–oversubscribe"><a href="#参数-–use-hwthread-cpus-与-–oversubscribe" class="headerlink" title="参数  –use-hwthread-cpus  与  –oversubscribe"></a>参数  –use-hwthread-cpus  与  –oversubscribe</h1><p>前面我们知道 A、B主机的CPU物理核心个数：</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>&#x3D;&#x3D;-np 指定该次运行一共需要的CPU个数&#x3D;&#x3D;，-nolocal 指定不使用当前主机的CPU进行运算，myhosts中指定参与计算的各主机的最多参与计算的CPU个数。</p><p>正如我们前面所说的，myhosts文件中虽然可以指定每个主机最多可以使用的CPU个数，但是这个个数是我们人为设定的，设定的一个要求就是要小于主机的物理核心个数。如果myhosts 中slots指定的CPU数量等于主机物理核心个数那么slots本身是没有意义的，因为myhosts中不使用slots设定所能使用的最多CPU个数也是该主机的物理核心个数。</p><p>那么 myhosts 中slots的个数设定真的不能大于主机的物理核心数，其实不然。之所以我们默认要求slots个数不能大于物理核心数是因为在<strong>独占</strong>主机进行<strong>计算密集型</strong>运算时当主机上运行的进程数等于物理核心数时往往会得到最高的利用率。</p><p>一个隐藏知识，根据Intel cpu的白皮书（蓝皮书）可以看到在使用超流水线多线程运算时密集计算型计算性能可以提高30%，这就是说在Intel超流水线技术支持下，密集计算任务单主机下进程数等于逻辑核心个数其性能要&#x3D;&#x3D;超进程数等于物理核心数&#x3D;&#x3D;时的30%，不过这只是在短时间计算情景下，如果在长时间运行情况下当进程数等于逻辑核心数时计算密集型任务往往会导致CPU的散热撞到功率墙（散热墙）从而导致大幅度CPU降频，从而导致计算性能大幅下降，当然这说的是普通散热情况下，因此在进行计算密集型计算任务时我们都是默认设定进程数等于物理核心数。</p><p>也就是说，如果我们在 myhosts 文件中设定 slots 个数超过主机的物理核心数在不考虑计算性能的情况下是完全可行的。</p><p>给出此时的myhosts内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=100</span><br><span class="line">192.168.11.206      slots=100</span><br></pre></td></tr></table></figure><p>运行语句中如下：</p><p><code>mpirun -np 200  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。共运行200个进程，其中100个进程运行在A主机192.168.11.66 上， 100个进程运行在B主机192.168.11.206 上。</p><p>由此可见使用 myhosts文件中的slots设定也是可以运行超过物理核心数的进程的。</p><p>刚才说的是在使用 –machinefile 参数 利用myhosts 文件中的设定来实现超过物理核心数的进程数量运行的，如果我们不使用 –machinefile 参数的情况下呢？？？</p><h1 id="参数-–host"><a href="#参数-–host" class="headerlink" title="参数 –host"></a>参数 –host</h1><p>执行命令：</p><p><code>mpirun -np 8  --host 192.168.11.66:4 --host 192.168.11.206:4   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行4个进程，在B主机192.168.11.206上运行4个进程，共运行8个进程。</p><p>执行命令：</p><p><code>mpirun -np 6  --host 192.168.11.206:6   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在B主机192.168.11.206上运行6个进程，共运行6个进程。</p><p>执行命令：</p><p><code>mpirun -np 200  --host 192.168.11.66:100 --host 192.168.11.206:100   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行100个进程，在B主机192.168.11.206上运行100个进程，共运行200个进程。</p><p>执行命令：</p><p><code>mpirun -np 200 --host 192.168.11.206:200   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在B主机192.168.11.206上运行200个进程，共运行200个进程。</p><p>当然上面的都是在分布式的环境下运行的（ 分布式环境下是指使用 –host 参数）。</p><p>如果不使用 –host 参数，在单机环境下如何实现超过物理核心数的进程数运行呢？？？</p><p>如：</p><p>执行命令：</p><p><code>mpirun -np 48   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>命令的含义是在A主机192.168.11.66上运行48个进程，而A主机的物理核心数为24，因此报错。</p><p>There are notenough slots available inthe system to satisfy the 48<br>slots that were requested by the application:</p><p>这时改用命令：（加入参数 –use-hwthread-cpus ）</p><p>--use-hwthread-cpus 参数的含义是允许当前主机运行的进程最大数为逻辑核心数而不是物理核心数。</p><p><code>mpirun -np 48 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在A主机192.168.11.66上运行48个进程，A主机为当前命令执行时所在的主机，其逻辑核心数为48。</p><p>改命令为：</p><p><code>mpirun -np 49 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行失败，因为 –use-hwthread-cpus 参数只能设定最多运行进程数为逻辑核心数，因此超过48后报错（A主机逻辑核心数为48）。</p><p>这时改用 参数 –oversubscribe ：</p><p>--oversubscribe 参数的含义就是不对进程数设限制，也就是说进程数可以随便设置。</p><p>执行命令如下：</p><p><code>mpirun -np 200  --oversubscribe  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66上运行了200个进程。</p><h1 id="附加内容："><a href="#附加内容：" class="headerlink" title="附加内容："></a>附加内容：</h1><p>在执行mpi程序时rank0进程是在哪个主机上呢？？？</p><p>（rank0进程就是mpi程序运行后rank排名号为0号的进程）</p><p>在主机A 192.168.11.66 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在A主机 192.168.11.66上。</p><p>同理：</p><p>在主机B 192.168.11.206 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在B主机 192.168.11.206上。</p><p>由上面的运行情况我们可以知道 rank0 进程一般都是运行在启动mpi程序并使用CPU运行进程的主机上（需要排除使用参数 -nolocal 的情况，该种情况启动mpi程序的主机是不使用CPU参与计算的，因此rank0进程此时是不在启动mpi程序的主机上的）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mpirun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-basic</title>
      <link href="/2023/04/20/vscode-basic/"/>
      <url>/2023/04/20/vscode-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>打开<a href="https://code.visualstudio.com/">Vscode</a> 官网直接下载即可</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ol><li><p>Python</p><p>Python为VSCode添加了对Python的语言支持，包括 IntelliSense 和Debugging等功能</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145247297.png" alt="image-20230420145247297"></p><ol start="2"><li><p>Jupyter</p><p>  Jupyter为VSCode添加了对Jupyter Notebook的功能支持</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145530009.png" alt="image-20230420145530009"></p><ol start="3"><li><p>Code Runner</p><p>Code Runner用于直接运行多种语言的代码片段或文件</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145551529.png" alt="image-20230420145551529"></p><ol start="4"><li><p>Better Comments</p><p>Better Comments为代码注释提供各种特定类型注释的高亮。</p></li></ol><p> <img src="/2023/04/20/vscode-basic/image-20230420145609253.png" alt="image-20230420145609253"></p><ol start="5"><li><p>Bracket Pair Colorizer</p><p>给匹配的括号着色</p></li><li><p>Indent-Rainbow</p><p>让缩进带有颜色</p></li><li><p>Path Intellisense</p><p>自动完成文件名</p></li><li><p>Prettier - Code formatter</p><p>更优雅的代码格式化,vscode 里比较优秀的一个格式化插件</p></li><li><p>matlab插件</p><p>支持自动补全、跳转定义、变量重命名 </p></li><li><p>Remote-SSH</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145707498.png" alt="image-20230420145707498"></p><ol start="11"><li><p>Markdown Preview Enhanced（markdown 预览增强）</p></li><li><p>GitHub Pull Requests and Issues</p><p>自动识别仓库变动，一键push和pull，特别方便</p><p><img src="/2023/04/20/vscode-basic/image-20230423173040299.png" alt="image-20230423173040299"></p></li><li><p>WD-TabNine</p><p>非常强大的代码自动补全工具</p></li></ol><h1 id="Remote-SSH连接"><a href="#Remote-SSH连接" class="headerlink" title="Remote-SSH连接"></a>Remote-SSH连接</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装Remote-SSHR之后，点击界面左下角的打开远程窗口</p><p><img src="/2023/04/20/vscode-basic/image-20230420145744807.png" alt="image-20230420145744807"></p><p>选择Connect to Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145758242.png" alt="image-20230420145758242"></p><p>选择Add New SSH Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145807767.png" alt="image-20230420145807767"></p><p>输入对应的用户名和远程IP地址</p><p><img src="/2023/04/20/vscode-basic/image-20230420145813675.png" alt="image-20230420145813675"></p><p>在弹出的设置配置文件路径，选择第一项</p><p><img src="/2023/04/20/vscode-basic/image-20230420145819225.png" alt="image-20230420145819225"></p><p>界面右下角显示Host added!</p><p><img src="/2023/04/20/vscode-basic/image-20230420145824770.png" alt="image-20230420145824770"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>添加host成功之后，再点击左下角的打开远程连接窗口，</p><p>  <img src="/2023/04/20/vscode-basic/image-20230420145829467.png" alt="image-20230420145829467"></p><p>就会出现刚刚配置好的host，点击，输入密码，就可以成功登录了</p><p> <img src="/2023/04/20/vscode-basic/image-20230420145837776.png" alt="image-20230420145837776"></p><h2 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h2><p>登录成功后，为了避免每次输入密码，在linux服务器上添加公钥（参考添加公钥到github）;</p><p>在远程终端上</p><p>先定位目录<br><code> cd .ssh</code></p><p>再看看有没有authorized_keys文件：<br> <code>ls</code></p><p>然后编辑它<br><code> vim authorized_keys</code></p><p>然后按i进入编辑模式<br> 然后把本机 后缀.pub文件（比如id_rsa.pub）的内容粘贴上去：<br> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPsqZlc1lASXIwrOSpyyghF+U 一大串</p><p>最后 按ESC 然后输入:wq （写入内容并quit退出）<br> 然后关闭vscode窗口自动断开链接，再按 第3步 直接点击 然后直接连接上并成功登录！</p><h1 id="使用远程服务器上的jypyter"><a href="#使用远程服务器上的jypyter" class="headerlink" title="使用远程服务器上的jypyter"></a>使用远程服务器上的jypyter</h1><h2 id="启动jupyper-服务器"><a href="#启动jupyper-服务器" class="headerlink" title="启动jupyper 服务器"></a>启动jupyper 服务器</h2><p>在终端激活对应的conda 虚拟环境之后，输入jupyter notebook，启动jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145849003.png" alt="image-20230420145849003"></p><p>复制下面的地址，两个都可以</p><p><img src="/2023/04/20/vscode-basic/image-20230420145854628.png" alt="image-20230420145854628"></p><h2 id="vscode中连接远程jupyter"><a href="#vscode中连接远程jupyter" class="headerlink" title="vscode中连接远程jupyter"></a>vscode中连接远程jupyter</h2><p>安装juyter拓展后，按快捷键打开输入框，输入jupyter以后就可以看到以下提示，选择为连接指定jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145901403.png" alt="image-20230420145901403"></p><p>之后进入以下界面，需要输入刚刚已启动的jupyter notebook的URL连接，如上的两个链接，复制输入框中按回车就可以连接服务器上的jupyter</p><p><img src="/2023/04/20/vscode-basic/image-20230420145907727.png" alt="image-20230420145907727"></p><p>此时就可以选择新建或打开远程服务器上的ipynb文件，可能会提示要为远程服务器安装python拓展，确认安装即可。</p><h2 id="切换虚拟环境"><a href="#切换虚拟环境" class="headerlink" title="切换虚拟环境"></a>切换虚拟环境</h2><p>服务器上配置有多个 <a href="https://so.csdn.net/so/search?q=conda&spm=1001.2101.3001.7020">conda</a> 虚拟环境，如果每次启动jupyter之前需要激活对应的虚拟环境，后续就不方便切换，</p><p>使用nb_conda_kernels 添加所有环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate base   # could be also some other environment</span><br><span class="line"></span><br><span class="line">conda install nb_conda_kernels</span><br><span class="line"></span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>安装好后，打开 jupyter notebook 就会显示所有的 conda 环境</p><p><img src="/2023/04/20/vscode-basic/image-20230420145917965.png" alt="image-20230420145917965"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

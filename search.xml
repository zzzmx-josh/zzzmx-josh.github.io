<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。基本上所有编程语言都支持正则表达式。</p><h1 id="python-re库"><a href="#python-re库" class="headerlink" title="python re库"></a>python re库</h1><p>re库使Python 语言拥有全部的正则表达式功能，主要使用re库提供的四个函数：</p><ol><li><p>re.match：</p><p>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none</p><p>语法：re.match(pattern, string, flags=0)</p></li><li><p>re.search：</p><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p><p>语法：</p><p>re.search(pattern, string, flags=0)</p></li><li><p>re.findall：</p><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表</p><p>语法：</p><p>re.findall(string[, pos[, endpos]])</p></li><li><p>re.sub:</p><p>sub是substitute的所写，表示替换，将匹配到的数据进⾏替换</p><p>语法：</p><p>re.sub(pattern, repl, string, count=0, flags=0)</p></li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None</li><li>re.search匹配整个字符串，直到找到一个匹配</li><li>re.match 和 re.search 只匹配一次， re.findall 匹配所有</li></ul><p>具体使用方法请参考链接<a href="%5Bhttps://zhuanlan.zhihu.com/p/127807805%5D">^1</a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;-100,abc2.4-123s,hello!!%d-1ds-0V11c.234as123.2s1.3bb.24&#x27;</span></span><br><span class="line">ret = re.findall(<span class="string">r&#x27;-?\d+\.?\d*e?-?\d*&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>(-?\d \.?\d*e?-?\d*?)：匹配数字，包括整数、小数和负数。</p></li><li><p>-? 表示可选的负号</p></li><li><p>\d 表示匹配一个数字</p></li><li><p>\.? 表示可选的小数点</p></li><li><p>\d* 表示匹配 0 个或多个数字</p></li><li><p>e? 表示可选的 e 字符，科学计数法</p></li><li><p>-?\d* 表示可选的负号和 0 个或多个数字。</p></li></ul><p>这个正则表达式可以匹配以下类型的字符串：</p><ul><li>3.14</li><li>-1.23</li><li>0.5</li><li>42.0</li><li>1.23e4</li><li>-3.14e-2</li><li>6.02e23</li><li>-1.0e-10</li></ul><h2 id="提取指定字符前或后的数字"><a href="#提取指定字符前或后的数字" class="headerlink" title="提取指定字符前或后的数字"></a>提取指定字符前或后的数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;-100,abc2.4-123s,hello!!%d-1ds-0V1.111c.234as123.2s1.3bb.24&#x27;</span></span><br><span class="line">number = re.findall(<span class="string">r&#x27;-?\d+\.?\d*e?-?\d*&#x27;</span>,<span class="built_in">str</span>) <span class="comment">#提取所有数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所有数字：&#x27;</span>,number)</span><br><span class="line">number = re.findall(<span class="string">r&quot;(?&lt;=V)-?\d+\.?\d*e?-?\d*&quot;</span>,<span class="built_in">str</span>) <span class="comment">#提取指定字符后数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;指定字符后：&#x27;</span>,number)</span><br><span class="line">number = re.findall(<span class="string">r&quot;(-?\d+\.?\d*e?-?\d*)V&quot;</span>,<span class="built_in">str</span>) <span class="comment">#提取指定字符前的数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;指定字符前：&#x27;</span>,number)</span><br><span class="line"><span class="comment"># 下面这个转换要看具体情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;testH33+&quot;</span></span><br><span class="line">str_ = re.findall(<span class="string">r&quot;\w\d&#123;1,2&#125;(?=+)&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="comment">#搜索&quot;+&quot;前面&quot;H33&quot;。\w代表一个字母，\d代表数字，&#123;1,2&#125;:前面的数字有1到2个，(?=+)表示要匹配的字符在&quot;+&quot;前面。</span></span><br><span class="line"><span class="built_in">print</span>(str_)</span><br></pre></td></tr></table></figure><p> 输出结果：</p><p>所有数字： [‘-100’, ‘2.4e1123’, ‘-1’, ‘-0’, ‘1.111’, ‘234’, ‘123.2’, ‘1.3’, ‘24’]<br>指定字符后： [‘1.111’]<br>指定字符前： [‘-0’]</p><h2 id="文件按照特定字符排序"><a href="#文件按照特定字符排序" class="headerlink" title="文件按照特定字符排序"></a>文件按照特定字符排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先找到当前目录下所有的文件</span></span><br><span class="line">path = Path.cwd()</span><br><span class="line"><span class="comment"># 匹配所有以kij开头的文件</span></span><br><span class="line">filelist = [(path) <span class="keyword">for</span> path <span class="keyword">in</span> <span class="built_in">list</span>(path.glob(<span class="string">&quot;kij*&quot;</span>))]</span><br><span class="line"><span class="comment">#将文件名按照_kij前面匹配到的顺序排序</span></span><br><span class="line"><span class="comment"># 此处_kij前面的数字为整数，如果是小数，请将int更换成float，默认升序</span></span><br><span class="line">file_list = <span class="built_in">sorted</span>(filelist,key=<span class="keyword">lambda</span> f: <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;(-?\d+\.?\d*e?-?\d*)_kij&#x27;</span>,<span class="built_in">str</span>(f))[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://www.runoob.com/python/python-reg-expressions.html">https://www.runoob.com/python/python-reg-expressions.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/127807805">https://zhuanlan.zhihu.com/p/127807805</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim配置</title>
      <link href="/2023/05/04/vim%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/05/04/vim%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Linux最早的编辑器为vi，Visual interface的缩写。后来在vi的基础上通过扩展插件升级就有了vim，vim是vi improve的缩写。</p><p>vim作为一款模式化编辑器，有三种模式：</p><p>1、编辑模式（也叫命令模式，是打开文件进入的默认模式）</p><p>2、输入模式</p><p>3、末行模式</p><p>具体使用教程请参考：</p><p><a href="https://zhuanlan.zhihu.com/p/68111471">https://zhuanlan.zhihu.com/p/68111471</a></p><p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">https://www.runoob.com/w3cnote/all-vim-cheatsheat.html</a></p><p><img src="/2023/05/04/vim%E9%85%8D%E7%BD%AE/vi-vim-cheat-sheet-sch1.gif" alt="vi-vim-cheat-sheet-sch"></p><h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible &quot;不与 Vi 兼容（采用 Vim 操作命令）&quot;</span><br><span class="line">hi  comment ctermfg=4 &quot;默认注释颜色是4，即ctermfg=4，有0，1，2，3，4，5，6，7供选:0 黑色 1  红色 2 墨绿 3 黄色 4 蓝色，即默认的颜色 5 粉色 6 淡蓝色 7  白色 &quot;</span><br><span class="line">syntax on  &quot;开启语法高亮&quot;</span><br><span class="line">set number  &quot;显示行号&quot;</span><br><span class="line">filetype indent on &quot;开启文件类型检查，并且载入与该类型对应的缩进规则&quot;</span><br><span class="line">set fenc=utf-8      &quot;文件编码&quot;</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set scrolloff=5     &quot;距离顶部和底部5行&quot;</span><br><span class="line">set laststatus=2    &quot;命令行为两行&quot;</span><br><span class="line">set backspace=2 &quot;能使用backspace回删&quot;</span><br><span class="line">set mouse=a     &quot;启用鼠标&quot;</span><br><span class="line">&quot;set autoindent &quot;按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致&quot; &quot; </span><br><span class="line">set smartindent &quot;每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（&#125;），则取消缩进形式;识别C语言关键字&quot;</span><br><span class="line">&quot;set cindent     &quot;设置C样式的缩进格式&quot; &quot;</span><br><span class="line">set shiftwidth=4        &quot;在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数&quot;</span><br><span class="line">set tabstop=4   &quot;设置table长度&quot;</span><br><span class="line">set textwidth=80 &quot;设置行宽&quot;</span><br><span class="line">set showmatch   &quot;显示匹配的括号&quot;</span><br><span class="line">set matchtime=5 &quot;控制显示配对括号的时间&quot;</span><br><span class="line">&quot;自动匹配括号inoremap命令用于映射按键 &quot;</span><br><span class="line">inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">inoremap [ []&lt;ESC&gt;i</span><br><span class="line">inoremap &#123; &#123;&#125;&lt;ESC&gt;i</span><br><span class="line">inoremap &lt; &lt;&gt;&lt;ESC&gt;i</span><br><span class="line">inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">set ignorecase      &quot;搜索不区分大小写&quot;</span><br><span class="line">set incsearch      &quot;输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果&quot;</span><br><span class="line">set smartcase    &quot;智能大小写搜索&quot;</span><br><span class="line">set hlsearch        &quot;高亮搜索项&quot;</span><br><span class="line"></span><br><span class="line">set selection=inclusive &quot;选择文本时，光标所在位置也属于被选中的范围&quot;</span><br><span class="line">set selectmode=mouse,key &quot;使用鼠标键盘选中文本&quot;</span><br><span class="line">set wildmenu</span><br><span class="line">set wildmode=longest:list,full  &quot;命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令&quot;</span><br><span class="line"></span><br><span class="line">set nowrap  &quot;设置不折行&quot;</span><br><span class="line">set wrap &quot;自动折行，即太长的行分成几行显示&quot;</span><br><span class="line">set ruler &quot;在状态栏显示光标的当前位置（位于哪一行哪一列）&quot;</span><br><span class="line">set undofile  &quot;保留撤销历史&quot;</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l &quot;允许backspace和光标键跨越行边界&quot;</span><br><span class="line"></span><br><span class="line">set showmode   &quot;在底部显示，当前处于命令模式还是插入模式&quot;</span><br><span class="line">set showcmd    &quot;命令模式下，在底部显示，当前键入的指令&quot;</span><br><span class="line">set showmatch  &quot;自动高亮对应的另一个圆括号、方括号和大括号&quot;</span><br><span class="line">set guifont=Monaco:h13   &quot;设置字体&quot;    </span><br><span class="line">set showtabline=0 &quot;隐藏顶部标签栏&quot;</span><br><span class="line">set autoread &quot;打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示&quot;</span><br><span class="line">&quot; 隐藏滚动条&quot;    </span><br><span class="line">set guioptions-=r </span><br><span class="line">set guioptions-=L</span><br><span class="line">set guioptions-=b</span><br><span class="line"></span><br><span class="line">&quot;插件设置&quot;</span><br><span class="line">filetype plugin on  &quot;允许vim加载文件类型插件&quot;</span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">&quot; Shorthand notation for plugin</span><br><span class="line">Plug &#x27;Lattay/vasp.vim&#x27;</span><br><span class="line">call plug#end()</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on  </span><br><span class="line">Plugin &#x27;Lokaltog/vim-powerline&#x27;</span><br><span class="line">Plugin &#x27;scrooloose/nerdtree&#x27;</span><br><span class="line">Plugin &#x27;Yggdroot/indentLine&#x27;</span><br><span class="line">Plugin &#x27;jiangmiao/auto-pairs&#x27;</span><br><span class="line">Plugin &#x27;tell-k/vim-autopep8&#x27;</span><br><span class="line">Plugin &#x27;scrooloose/nerdcommenter&#x27;</span><br><span class="line">Plugin &#x27;L9&#x27;</span><br><span class="line"></span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt; &quot;F2开启和关闭树&quot;</span><br><span class="line">let NERDTreeChDirMode=1</span><br><span class="line">&quot;显示书签&quot;</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br><span class="line">&quot;设置忽略文件类型&quot;</span><br><span class="line">let NERDTreeIgnore=[&#x27;\~$&#x27;, &#x27;\.pyc$&#x27;, &#x27;\.swp$&#x27;]</span><br><span class="line">&quot;窗口大小&quot;</span><br><span class="line">let NERDTreeWinSize=25</span><br><span class="line">let g:pydiction_location = &#x27;~/.vim/tools/pydiction/complete-dict&#x27;</span><br><span class="line">let g:pydiction_menu_height = 3</span><br><span class="line"></span><br><span class="line">&quot;缩进指示线&quot;</span><br><span class="line">let g:indentLine_char=&#x27;┆&#x27;</span><br><span class="line">let g:indentLine_enabled = 1</span><br><span class="line">&quot;autopep8设置&quot;</span><br><span class="line">let g:autopep8_disable_show_diff=1</span><br><span class="line">&quot;comment F4自动注释&quot;</span><br><span class="line">map &lt;F4&gt; &lt;leader&gt;ci &lt;CR&gt;</span><br><span class="line">&quot;默认配置文件路径&quot;</span><br><span class="line">let g:ycm_global_ycm_extra_conf = &#x27;~/.ycm_extra_conf.py&#x27;</span><br><span class="line">&quot;打开vim时不再询问是否加载ycm_extra_conf.py配置&quot;</span><br><span class="line">let g:ycm_confirm_extra_conf=0</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">&quot;python解释器路径&quot;</span><br><span class="line">let g:ycm_path_to_python_interpreter=&#x27;~/mambaforge3/envs/ubermag/bin/python&#x27;</span><br><span class="line">&quot;是否开启语义补全&quot;</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax=1</span><br><span class="line">&quot;是否在注释中也开启补全&quot;</span><br><span class="line">let g:ycm_complete_in_comments=1</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 0</span><br><span class="line">&quot;开始补全的字符数&quot;</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion=2</span><br><span class="line">&quot;补全后自动关机预览窗口&quot;</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=1</span><br><span class="line">&quot; 禁止缓存匹配项,每次都重新生成匹配项&quot;</span><br><span class="line">let g:ycm_cache_omnifunc=0</span><br><span class="line">&quot;字符串中也开启补全&quot;</span><br><span class="line">let g:ycm_complete_in_strings = 1</span><br><span class="line">&quot;离开插入模式后自动关闭预览窗口&quot;</span><br><span class="line">autocmd InsertLeave * if pumvisible() == 0|pclose|endif</span><br><span class="line"></span><br><span class="line">&quot;上下左右键行为&quot;</span><br><span class="line">&quot;inoremap &lt;expr&gt; &lt;Down&gt;    pumvisible() ? &#x27;\&lt;C-n&gt;&#x27; : &#x27;\&lt;Down&gt;&#x27;&quot;</span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? &#x27;\&lt;C-p&gt;&#x27; : &#x27;\&lt;Up&gt;&#x27;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? &#x27;\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;&#x27; : &#x27;\&lt;PageDown&gt;&#x27;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? &#x27;\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;&#x27; : &#x27;\&lt;PageUp&gt;&#x27;</span><br><span class="line">&quot;&quot;=============================================================================</span><br><span class="line">&quot; shell 和 python文件的注释</span><br><span class="line">&quot; ============================================================================</span><br><span class="line">autocmd BufNewFile *.py,*.sh, exec &quot;:call SetTitle()&quot;</span><br><span class="line">let $author_name = &quot;zzmx_josh&quot;</span><br><span class="line">let $author_email = &quot;zmxzmx1997@outlook.com&quot;</span><br><span class="line">function SetTitle()</span><br><span class="line">    if &amp;filetype == &#x27;sh&#x27;</span><br><span class="line">        call setline(1,&quot;\#!/bin/bash&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;),&quot;\# ---------------------------------------------&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+1,    &quot;\# File Name   : &quot;.expand(&quot;%&quot;))</span><br><span class="line">        call append(line(&quot;.&quot;)+2,    &quot;\# Author      : &quot;.$author_name)</span><br><span class="line">        call append(line(&quot;.&quot;)+3,    &quot;\# Mail        : &quot;.$author_email)</span><br><span class="line">        call append(line(&quot;.&quot;)+4,    &quot;\# Date        : &quot;.strftime(&#x27;%Y-%m-%d&#x27;, localtime()))</span><br><span class="line">        call append(line(&quot;.&quot;)+5,    &quot;\# Description : &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+6,    &quot;\# ---------------------------------------------&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7,    &quot;&quot;)</span><br><span class="line">    else</span><br><span class="line">        call setline(1,&quot;\#!/usr/bin/python&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;),     &quot;\# file name   : &quot;.expand(&quot;%&quot;))</span><br><span class="line">        call append(line(&quot;.&quot;)+1,   &quot;\# Author      : &quot;.$author_name)</span><br><span class="line">        call append(line(&quot;.&quot;)+2,   &quot;\# Mail        : &quot;.$author_email)</span><br><span class="line">        call append(line(&quot;.&quot;)+3,   &quot;\# Create Time : &quot;.strftime(&#x27;%Y-%m-%d %H:%M&#x27;,localtime()))</span><br><span class="line">        call append(line(&quot;.&quot;)+4,   &quot;\# Description : &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+5,   &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">autocmd BufNewfile * normal G &quot;将光标移动到新文件的最后一行&quot;</span><br><span class="line">&quot;为Shell脚本文件添加可执行权限&quot;</span><br><span class="line">au BufWritePost * if getline(1) =~ &quot;^#!&quot; | if getline(1) =~ &quot;/bin/&quot; | silent !chmod +x &lt;afile&gt; | endif | endif</span><br></pre></td></tr></table></figure><p>上面的配置可以直接复制，然后粘贴到~&#x2F;.vimrc中使用。如果没有安装插件，请将相关的配置删除。</p><p>参考链接：</p><p><a href="https://ruanyifeng.com/blog/2018/09/vimrc.html">https://ruanyifeng.com/blog/2018/09/vimrc.html</a></p><p><a href="https://www.cnblogs.com/litifeng/p/5651472.html">https://www.cnblogs.com/litifeng/p/5651472.html</a></p><p><a href="https://www.jianshu.com/p/0c83e6aed270">https://www.jianshu.com/p/0c83e6aed270</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强大的shell-zsh</title>
      <link href="/2023/05/01/%E5%BC%BA%E5%A4%A7%E7%9A%84shell-zsh/"/>
      <url>/2023/05/01/%E5%BC%BA%E5%A4%A7%E7%9A%84shell-zsh/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>zsh或许可以认为是最好的shell，对于我这种记不住终端命令的人来说简直是神器。自从从bash转zsh之后，使用Linux命令直接起飞，非常得心应手。zsh相比较bash所具有的特点：</p><p>1. 更好的命令补全功能：zsh的命令补全功能比bash更强大和智能，支持更多的选项和自动提示。</p><p>2. 自定义主题和插件：zsh提供了更多的主题和插件，可让用户轻松自定义命令提示符和命令别名等。</p><p>3. 更好的历史记录管理：zsh支持更多的历史记录功能，包括事件时间戳、时间轴浏览、模糊搜索等。</p><p>4. 更高效的配置管理：zsh的配置文件可以使用zsh本身脚本语言而不仅仅是bash语法。</p><p>5. 其他特性包括补全脚本、自动文件名扩展、定时命令等，都只能在zsh中使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>mac默认的shell就是zsh，但是linux上需要用户自行安装，下面介绍的是没有root命令该如何从源代码安装：</p><h2 id="安装依赖ncurses"><a href="#安装依赖ncurses" class="headerlink" title="安装依赖ncurses"></a>安装依赖ncurses</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.invisible-island.net/ncurses/ncurses.tar.gz &amp;&amp; tar -zxvf ncurses.tar.gz</span><br><span class="line">./configure --enable-shared --prefix=$HOME/usr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O zsh.tar.gz https://sourceforge.net/projects/zsh/files/latest/download</span><br><span class="line">tar -zxvf zsh.tar.gz &amp;&amp; cd zsh</span><br><span class="line">export CPPFLAGS=&quot;-I$HOME/usr/include/&quot; LDFLAGS=&quot;-L$HOME/usr/lib&quot;</span><br><span class="line">./configure --prefix=$HOME/usr --enable-shared</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h1 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h1><p>zsh自定义配置，可供选择的插件以及主题非常多，因此一定要搭配oh-my-zsh。</p><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速安装</span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">手动安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从github上克隆oh-my-zsh，如果克隆失败，可能是网络问题，多尝试问题</span></span><br><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用oh-my-zsh的zsh配置文件替代</span></span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zhsrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一些字体, 不然一些主题会显示异常</span></span><br><span class="line">cd src</span><br><span class="line">git clone https://github.com/powerline/fonts.git --depth=1</span><br><span class="line">cd fonts &amp;&amp; ./install.sh</span><br></pre></td></tr></table></figure><p>重启一下终端，后面根据需要调整配置文件里的参数。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>oh my zsh 项目提供了完善的插件体系，相关的文件在~&#x2F;.oh-my-zsh&#x2F;plugins目录下，默认提供了100多种，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，就可以加载自己的插件了，系统默认加载 git，可以在后面追加内容，如下：</p><p>plugins&#x3D;(git autojump )</p><h3 id="路径任意跳转auto-jump"><a href="#路径任意跳转auto-jump" class="headerlink" title="路径任意跳转auto jump"></a>路径任意跳转auto jump</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins/ </span><br><span class="line"> git clone https://github.com/wting/autojump wting/autojump</span><br><span class="line">cd wting/autojump</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure><p>执行命令后，把屏幕上对应的文字添加bashrc中。</p><p>重新加载环境变量就可以用 j [各种短写路径] 跳转, tab 键提示有奇效</p><p>用法：输入 j 目录名 或 j 目录名包含的字符（这个目录必须是之前 cd 访问过的），就可直接切换到相应的目录。不用再各种cd啦～</p><h3 id="自动提示命令zsh-autosuggestions"><a href="#自动提示命令zsh-autosuggestions" class="headerlink" title="自动提示命令zsh-autosuggestions"></a>自动提示命令zsh-autosuggestions</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/.zshrc 中添加</span></span><br><span class="line">plugins=(</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果看不到变化，可能是字体颜色太淡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure><p>修改 ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE&#x3D;’fg&#x3D;10’</p><h3 id="语法高亮zsh-syntax-highlighting"><a href="#语法高亮zsh-syntax-highlighting" class="headerlink" title="语法高亮zsh-syntax-highlighting"></a>语法高亮zsh-syntax-highlighting</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/.zshrc 中添加</span></span><br><span class="line">plugins=(</span><br><span class="line">zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我目前就安装了这些插件，已经非常方便。</p><h1 id="设置zsh为默认shell"><a href="#设置zsh为默认shell" class="headerlink" title="设置zsh为默认shell"></a>设置zsh为默认shell</h1><p>为了将默认shell更改为zsh，需要在终端中运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export PATH=$HOME/usr/bin:$PATH&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;exec $HOME/usr/bin/zsh -l&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>我的zsh安装在$HOME&#x2F;usr&#x2F;bin目录下，也可以换成其他路径。上述命令将zsh安装的路径添加到<code>~/.bashrc</code> 文件中的 PATH 环境变量中，启动 zsh 并将其设置为默认shell。</p><p>退出当前终端并重新打开一个新终端，验证默认shell是否更改为zsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++模板(转载)</title>
      <link href="/2023/04/30/c-%E6%A8%A1%E6%9D%BF-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2023/04/30/c-%E6%A8%A1%E6%9D%BF-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://www.qixinbo.info/2017/07/09/cplusplus-template/">qixinbo</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>模板使类和函数可在编译时定义所需处理和返回的数据类型，一个模板并非一个实实在在的类或函数，仅仅是一个类和函数的描述。由于模板可以实现逻辑相同、数据类型不同的程序代码复制，所以使用模板机制可以减轻编程和维护的工作量和难度。模板一般分为模板函数和类模板。以所处理的数据类型的说明作为参数的类就叫类模板，或者模板类，而以所处理的数据类型的说明作为参数的函数，则称为函数模板。</p><p>本文包含函数模板和类模板，有些可能会交错设计两个模块的细节。</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板定义了参数化的非成员函数，这使得程序员能够用不同类型的参数调用相同的函数，由编译器决定调用哪一种类型，并且从模板中生成相应的代码。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Template﹤类型参数表﹥返回类型 函数名 （形参表）{函数体}</p><p>简单实例，调用函数打印字符串或数字等。</p><p>普通函数形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstring</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    </span><br><span class="line">    <span class="built_in">printstring</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//输出：Hello World</span></span><br></pre></td></tr></table></figure><p>模板函数形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">1234</span>;</span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line">    <span class="built_in">print</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Hello World </span></span><br><span class="line"><span class="comment">//       1234</span></span><br></pre></td></tr></table></figure><p>可以看出使用模板后的函数不仅可以输出字符串形式还可以输出数字形式的内容。</p><p>上面两个例子介绍了函数模板的简单使用方法，但只有一个参数，如果需要多个参数，相应的函数模板应采用以下形式定义：</p><p>Template﹤类型1 变量1，类型2 变量2 ，…﹥返回类型 函数名（形参表）{函数体}</p><p>现在，为了看到模板是如何成为函数的，我们假定min()函数接受各种类型的参数，并找出其中的最小者，如果不采用模板技术，则只能接受一个特定类型的参数，如果希望也能接受其他类型的参数，就需要对每一种类型的参数都定义一个同功能的函数，实际上为函数的重载。如：</p><p>普通定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个整数中最小的数，输入参数为整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min0</span><span class="params">(<span class="type">int</span> ii, <span class="type">int</span> jj, <span class="type">int</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个小数中最小的数，输入参数为浮点数</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">min1</span><span class="params">(<span class="type">float</span> ii, <span class="type">float</span> jj, <span class="type">float</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个子符中最小的字符，输入参数为字符</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">min2</span><span class="params">(<span class="type">char</span> ii, <span class="type">char</span> jj, <span class="type">char</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))    &#123;temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp1=<span class="built_in">min0</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    cout&lt;&lt;temp1&lt;&lt;endl;</span><br><span class="line">    <span class="type">float</span> temp2=<span class="built_in">min1</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>);</span><br><span class="line">    cout&lt;&lt;temp2&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> temp3=<span class="built_in">min2</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    cout&lt;&lt;temp3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以换行形式输出20  10.6  C</span></span><br></pre></td></tr></table></figure><p>使用模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk; &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果同上，但可以清楚地看到二者的工作量差距。</p><p>函数模板功能非常强大，但是有时候可能会陷入困境，假如待比较的函数模板没有提供正确的操作符，则程序不会对此进行编译。为了避免这种错误，可以使用函数模板和同名的非模板函数重载，这就是函数定制。函数模板与同名的非模板函数重载必须遵守以下规定：</p><ul><li>寻找一个参数完全匹配的函数，如有，则调用它</li><li>如果失败，寻找一个函数模板，使其实例化，产生一个匹配的模板函数，若有，则调用它</li><li>如果失败，再试低一级的对函数重载的方法，例如通过类型转换可产生的参数匹配等，若找到匹配的函数，调用它</li><li>如果失败，则证明这是一个错误的调用</li></ul><p>现在用上例的模板函数比较两个字符串，但会出现问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;     temp=ii; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123; temp=jj; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&quot;anderson&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Smith&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出anderson与实际结果不符，原因在于编译器会生成对字符串指针做比较的函数，但比较字符串和比较字符串指针是不一样的，为了解决此问题，我们可以定制函数模板，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;        temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;        temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非模板函数重载</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ch1, <span class="type">const</span> <span class="type">char</span>* ch2,<span class="type">const</span> <span class="type">char</span>* ch3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* temp;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">strcmp</span>(ch1,ch2);</span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">strcmp</span>(ch1,ch3);</span><br><span class="line">    <span class="type">int</span> result3 = <span class="built_in">strcmp</span>(ch2,ch1);</span><br><span class="line">    <span class="type">int</span> result4 = <span class="built_in">strcmp</span>(ch2,ch3);</span><br><span class="line">    <span class="keyword">if</span>((result1&lt;<span class="number">0</span>)&amp;&amp;(result2&lt;<span class="number">0</span>))    &#123;        temp = ch1;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((result3&lt;<span class="number">0</span>)&amp;&amp;(result4&lt;<span class="number">0</span>))    &#123;        temp=ch2;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=ch3;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)&lt;&lt;endl;    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&quot;anderson&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Smith&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VS2010中，最后一行会输出Smith，与结果相符。<br>注意：若上例在VC++ 6.0 中运行，其结果最后一行仍会输出anderson，读者可自己上机查看情况并分析原因。</p><p>下面给出一些实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_MY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_MY</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fromString</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">    T t;</span><br><span class="line">    is&gt;&gt;t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream t;</span><br><span class="line">    t&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HEADER.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">1234</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(i) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    <span class="type">float</span> x = <span class="number">567.89</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(x) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    <span class="function">complex&lt;<span class="type">float</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(c) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    i = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">string</span>(<span class="string">&quot;1234&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i == &quot;</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">    x = <span class="built_in">fromString</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">string</span>(<span class="string">&quot;567.89&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x == &quot;</span> &lt;&lt; x &lt;&lt; endl; </span><br><span class="line">    c = fromString&lt; complex&lt;<span class="type">float</span>&gt; &gt;(<span class="built_in">string</span>(<span class="string">&quot;(1.0,2.0)&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c == &quot;</span> &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板实参推演"><a href="#模板实参推演" class="headerlink" title="模板实参推演"></a>模板实参推演</h2><p>当函数模板被调用时，通过对对函数实参类型检查来决定模板实参的类型和值的这个过程叫做模板实参推演。如template <code>&lt;class T&gt;</code> void h(T a){}; h(1); h(0.2);第一个调用因为实参是int型的，所以模板形参T被推演为int型，第二个T的类型则为double。</p><p>在使用函数模板时，请注意以下几点：</p><ul><li>在模板被实例化后，就会生成一个新的实例，这个新生成的实例不存在类型转换。比如有函数模板template <code>&lt;class T&gt;</code>void H(T a){};int a&#x3D;2; short b&#x3D;3;第一个调用H(a)生成一个int型的实例版本，但是当调用h(b)的时候不会使用上次生成的int实例把short转换为int，而是会另外生成一个新的short型的实例。</li><li>在模板实参推演的过程中有时类型并不会完全匹配，这时编译器允许以下几种实参到模板形参的转换，这些转换不会生成新的实例。<br>(1) 数组到指针的转换或函数到指针的转换：比如template<code>&lt;class T&gt;</code> void h(T * a){}，int b[3]&#x3D;{1,2,3}；h(b);这时数组b和类型T <em>不是完全匹配，但允许从数组到指针的转换，因此数组b被转换成int <em>，而类型形参T被转换成int，也就是说函数体中的T被替换成int。<br>(2) 限制修饰符转换：即把const或volatile限定符加到指针上。比如template<code>&lt;class T&gt;</code> void h(const T</em> a){}，int b&#x3D;3; h(&amp;b);虽然实参&amp;b与形参const T</em>不完全匹配，但因为允许限制修饰符的转换，结果就把&amp;b转换成const int *。而类形型参T被转换成int。如果模板形参是非const类型，则无论实参是const类型还是非const类型调用都不会产生新的实例。<br>(3) 到一个基类的转换(该基类根据一个类模板实例化而来)：比如tessmplate<code>&lt;class T1&gt;</code> class A{}; template<code>&lt;class T1&gt;</code> class B:public A<code>&lt;T1&gt;</code>{}; template<code>&lt;class T2&gt;</code> void h(A<code>&lt;T2&gt;</code>&amp; m){}，在main函数中有B<code>&lt;int&gt;</code> n; h(n);函数调用的子类对象n与函数的形参A<code>&lt;T2&gt;</code>不完全匹配，但允许到一个基类的转换。在这里转换的顺序为，首先把子类对象n转换为基类对象A<code>&lt;int&gt;</code>，然后再用A<code>&lt;int&gt;</code>去匹配函数的形参A<code>&lt;T2&gt;</code>&amp;，所以最后T2被转换为int，也就是说函数体中的T将被替换为int。</li><li>对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</li></ul><p>模板实参推演实例，说明内容较长，采用注释形式，但代码较乱：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(T a)</span></span>&#123;cout&lt;&lt;<span class="string">&quot; h()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125;  <span class="comment">//带有一个类型形参T的模板函数的定义方法，typeid(变量名).name()为测试变量类型的语句。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">(T a,T b)</span></span>&#123;T c;cout&lt;&lt;<span class="string">&quot; k()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125; <span class="comment">//注意语句T c。模板类型形参T可以用来声明变量，作为函数的返回类型，函数形参等凡是类类型能使用的地方。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T1 a, T2 b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot; f()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T2).<span class="built_in">name</span>()&lt;&lt;endl;&#125;   <span class="comment">//定义带有两个类型形参T1，T2的模板函数的方法template&lt;class T&gt; void g(const T* a)&#123;T b;cout&lt;&lt;&quot; g()&quot;&lt;&lt;typeid(b).name()&lt;&lt;endl;&#125; </span></span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void g()&#123;&#125;  //错误，默认模板类型形参不能用于函数模板，只能用于类模板上。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line"><span class="comment">//函数模板实参推演示例。</span></span><br><span class="line"><span class="comment">// h(int); //错误，对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</span></span><br><span class="line"><span class="comment">//h函数形式为：template&lt;class T&gt;void h(T a)</span></span><br><span class="line"><span class="built_in">h</span>(<span class="number">2</span>);<span class="comment">//输出&quot; h() int&quot;使用函数模板推演，在这里数值2为int型，所以把类型形参T推演为int型。</span></span><br><span class="line"><span class="built_in">h</span>(<span class="number">2.0</span>);<span class="comment">//输出&quot; h() double&quot;，因为2.0为double型，所以将函数模板的类型形参推演为double型</span></span><br><span class="line"><span class="comment">//k函数形式为：template&lt;class T&gt;void k(T a,T b)</span></span><br><span class="line"><span class="built_in">k</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//输出&quot; k() int&quot;</span></span><br><span class="line"><span class="comment">//k(2,3.0);错误，模板形参T的类型不明确，因为k()函数第一个参数类型为int，第二个为double型，两个形参类型不一致。</span></span><br><span class="line"><span class="comment">//f函数的形式为：template&lt;class T1,class T2&gt; void f(T1 a, T2 b)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4.0</span>);<span class="comment">//输出&quot; f() int,double&quot;，这里不存在模板形参推演错误的问题，因为模板函数有两个类型形参T1和T2。在这里将T1推演为int，将T2推演为double。</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;<span class="type">double</span> b=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">f</span>(a,b); <span class="comment">//输出同上，这里用变量名实现推板实参的推演。</span></span><br><span class="line"><span class="comment">//模板函数推演允许的转换示例，g函数的形式为template&lt;class T&gt; void g(const T* a)</span></span><br><span class="line"><span class="type">int</span> a1[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="built_in">g</span>(a1); <span class="comment">//输出&quot; g() int&quot;，数组的地址和形参const T*不完全匹配，所以将a1的地址T &amp;转换为const T*，而a1是int型的，所以最后T推演为int。</span></span><br><span class="line"><span class="built_in">g</span>(&amp;b); <span class="comment">//输出&quot; g() double&quot;,这里和上面的一样，只是把类型T转换为double型。</span></span><br><span class="line"><span class="built_in">h</span>(&amp;b); <span class="comment">//输出&quot; h() double *&quot;这里把模参类型T推演为double *类型。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数模板的显式实例化"><a href="#函数模板的显式实例化" class="headerlink" title="函数模板的显式实例化"></a>函数模板的显式实例化</h2><ul><li>隐式实例化：比如有模板函数template<code>&lt;class T&gt;</code> void h(T a){}。h(2)这时h函数的调用就是隐式实例化，即参数T的类型是隐式确定的。</li><li>函数模板显式实例化声明：其语法是：template 函数返回类型 函数名 <code>&lt;实例化的类型&gt;</code> (函数形参表); 注意这是声明语句，要以分号结束。例如：template void h<code>&lt;int&gt;</code> (int a);这样就创建了一个h函数的int 实例。再如有模板函数template<code>&lt;class T&gt;</code> T h(T a){}，注意这里h函数的返回类型为T，显式实例化的方法为template int h<code>&lt;int&gt;</code>(int a); 把h模板函数实例化为int型。</li><li>对于给定的函数模板实例，显式实例化声明在一个文件中只能出现一次。</li><li>在显式实例化声明所在的文件中，函数模板的定义必须给出，如果定义不可见，就会发生错误。</li></ul><p>注意：不能在局部范围类显式实例化模板，实例化模板应放在全局范围内，即不能在main函数等局部范围中实例化模板。因为模板的声明或定义不能在局部范围或函数内进行。</p><h2 id="显式模板实参"><a href="#显式模板实参" class="headerlink" title="显式模板实参"></a>显式模板实参</h2><ol><li>显式模板实参：适用于函数模板，即在调用函数时显式指定要调用的实参的类型。</li><li>格式：显式模板实参的格式为在调用模板函数的时候在函数名后用<code>&lt;&gt;</code>尖括号括住要显示表示的类型，比如有模板函数template<code>&lt;class T&gt;</code> void h(T a, T b){}。则h<code>&lt;double&gt;</code>(2, 3.2)就把模板形参T显式实例化为double类型。</li><li>显式模板实参用于同一个模板形参的类型不一致的情况。比如template<code>&lt;class T&gt;</code> void h(T a, T b){}，则h(2, 3.2)的调用会出错，因为两个实参类型不一致，第一个为int 型，第二个为double型。而用h<code>&lt;double&gt;</code>(2, 3.2)就是正确的，虽然两个模板形参的类型不一致但这里把模板形参显式实例化为double类型，这样的话就允许进行标准的隐式类型转换，即这里把第一个int 参数转换为double类型的参数。</li><li>显式模板实参用法二：用于函数模板的返回类型中。例如有模板函数template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}，则语句int a&#x3D;h(2,3)或h(2,4)就会出现模板形参T1无法推导的情况。而语句int h(2,3)也会出错。用显式模板实参就能轻松解决这个问题，比如h<code>&lt;int, int, int&gt;</code>(2,3)即把模板形参T1实例化为int 型，T2和T3也实例化为int 型。</li><li>显式模板实参用法三：应用于模板函数的参数中没有出现模板形参的情况。比如template<code>&lt;class T&gt;</code>void h(){}如果在main函数中直接调用h函数如h()就会出现无法推演类型形参T的类型的错误，这时用显式模板实参就不会出现这种错误，调用方法为h<code>&lt;int&gt;</code>()，把h函数的模板形参实例化为int 型，从而避免这种错误。</li><li>显式模板实参用法四：用于函数模板的非类型形参。比如template<code>&lt;class T,int a&gt;</code> void h(T b){}，而调用h(3)将出错，因为这个调用无法为非类型形参推演出正确的参数。这时正确调用这个函数模板的方法为h<code>&lt;int, 3&gt;</code>(4)，首先把函数模板的类型形参T推演为int 型，然后把函数模板的非类型形参int a用数值3来推演，把变量a设置为3，然后再把4传递给函数的形参b，把b设置为4。注意，因为int a是非类型形参，所以调用非类型形参的实参应是编译时常量表达式，不然就会出错。</li><li>在使用显式模板实参时，我们只能省略掉尾部的实参。比如template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}在显式实例化时h<code>&lt;int&gt;</code>(3, 3.4)省略了最后两个模板实参T2和T3，T2和T3由调用时的实参3和3.4隐式确定为int 型和double型，而T1被显示确定为int 型。h<code>&lt;int, , double&gt;``&lt;2,3.4&gt;</code>是错误的，只能省略尾部的实参。</li><li>显式模板实参最好用在存在二义性或模板实参推演不能进行的情况下。</li></ol><p>下面来看看实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">g1</span><span class="params">(T a, T b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hansu g1()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="function">T1 <span class="title">g2</span><span class="params">(T2 a,T3 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;T1 c=a;cout&lt;&lt;<span class="string">&quot;hansug2()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in">typeid</span>(T2).<span class="built_in">name</span>()&lt;&lt;<span class="built_in">typeid</span>(T3).<span class="built_in">name</span>()&lt;&lt;endl; <span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt; <span class="type">void</span> <span class="title">g3</span> <span class="params">( T1 a )</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;hansu g3()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in">typeid</span>(T2).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="type">int</span> a&gt; <span class="type">void</span> <span class="title">g4</span><span class="params">(T1 b, <span class="type">double</span> c)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hansu g4()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in">typeid</span>(a).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="comment">//模板显示实例化示例。</span></span><br><span class="line"><span class="comment">//因为模板的声明或定义不能在局部范围或函数内进行。所以模板实例化都应在全局范围内进行。</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">g1</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> a,<span class="type">double</span> b); <span class="comment">//把函数模板显示实例化为int型。</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">double</span>,<span class="type">double</span>&gt;; <span class="comment">//显示实例化类模板，注意后面没有对象名，也没有&#123;&#125;大括号。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt;&#123;&#125;;  //错误，显示实例化类模板后面不能有大括号&#123;&#125;。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt; m;  //错误，显示实例化类模板后面不能有对象名。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//显示模板实参示例。显示模板实参适合于函数模板</span></span><br><span class="line"><span class="comment">//1、显示模板实参用于同一个模板形参的类型不一致的情况。函数g1形式为template&lt;class T&gt;void g1(T a, T b)</span></span><br><span class="line"><span class="built_in">g1</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//输出&quot;hansu g1() int&quot;两个实参类型不一致，第一个为int第二个为double。但这里用显示模板实参把类型形参T指定为double，所以第一个int型的实参数值2被转换为double类型。</span></span><br><span class="line"><span class="comment">//g1(2,3.2);错误，这里没有用显式模板实参。所以两个实参类型不一致。</span></span><br><span class="line"><span class="comment">//2、用于函数模板的反回类型中。函数g2形式为template&lt;class T1,class T2,class T3&gt; T1 g2(T2 a,T3 b)</span></span><br><span class="line"><span class="comment">//g2(2,3);错误，无法推演类型形参T1。</span></span><br><span class="line"><span class="comment">//int g2(2,3);错误，不能以这种方法试图推导类型形参T1为int型。</span></span><br><span class="line"><span class="comment">//int a=g2(2,3);错误，以这种方式试图推演出T1的类型为int也是错误的。</span></span><br><span class="line"><span class="built_in">g2</span>&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，将T1，T2，T3 显示指定为int型。输出&quot;hansu g2() intintint&quot;</span></span><br><span class="line"><span class="comment">//3、应用于模板函数的参数中没有出现模板形参的情况其中包括省略的用法，函数g3的形式为template&lt;class T1,class T2&gt; void g3(T1 a)</span></span><br><span class="line"><span class="comment">//g3(2);错误，无法为函数模板的类型形参T2推演出正确的类型</span></span><br><span class="line"><span class="comment">//g3(2,3);错误，岂图以这种方式为T2指定int型是错误的，因为函数只有一个参数。</span></span><br><span class="line"><span class="comment">//g3&lt;,int&gt;(2);错误，这里起图用数值2来推演出T1为int型,而省略掉第一个的显示模板实参，这种方法是错误的。在用显示模板实参时，只能省略掉尾部的实参。</span></span><br><span class="line"><span class="comment">//g3&lt;int&gt;(2);错误，虽然用了显示模板实参方法，省略掉了尾部的实参，但该方法只是把T1指定为int型，仍然无法为T2推演正确的类型。</span></span><br><span class="line"><span class="built_in">g3</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>);<span class="comment">//正确，显示指定T1和T2的类型都为int型。</span></span><br><span class="line"><span class="comment">//4、用于函数模板的非类型形参。g4函数的形式为template&lt;class T1,int a&gt; void g4(T1 b,double c)</span></span><br><span class="line"><span class="comment">//g4(3,3.2);错误，虽然指定了两个参数，但是这里仍然无法为函数模板的非类型形参int a推演出正确的实参。因为第二个函数参数x.2是传递给函数的参数double c的，而不是函数模板的非类型形参int a。</span></span><br><span class="line"><span class="comment">//g4(3,2);错误，起图以整型值把实参传递给函数模板的非类型形参是不行的，这里数值2会传递给函数形参double c并把int型转换为double型。所以非类型形参int a仍然无实参。</span></span><br><span class="line"><span class="comment">//int d=1; g4&lt;int ,d &gt;(3,3.2); //错误，调用方法正确，但对于非类型形参要求实参是一个常量表达式，而局部变量c是非常量表达式，不能做为非类型形参的实参，所以错误。</span></span><br><span class="line"><span class="built_in">g4</span>&lt;<span class="type">int</span>,<span class="number">1</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，用显示模板实参，把函数模板的类型形参T1设为int型，把数值1传给非类型形参int a，并把a设为1，把数值2 传给函数的第一个形参T1 b并把b设为2，数值?.2传给函数的第二个形参double c并把c设为?.2。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d=<span class="number">1</span>; <span class="built_in">g4</span>&lt;<span class="type">int</span>,d&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，这里变量d是const常量，能作为非类型形参的实参，这里参数的传递方法同上面的语句。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式具体化-模板特化，模板说明-和函数模板的重载"><a href="#显式具体化-模板特化，模板说明-和函数模板的重载" class="headerlink" title="显式具体化(模板特化，模板说明) 和函数模板的重载"></a>显式具体化(模板特化，模板说明) 和函数模板的重载</h2><ol><li>具体化或特化或模板说明指的是一个意思，就是把模板特殊化，比如有模板template<code>&lt;class T&gt;</code>void h(T a){}，这个模板适用于所有类型，但是有些特殊类型不需要与这个模板相同的操作或者定义，比如int 型的h实现的功能和这个模板的功能不一样，这样的话我们就要重定义一个h模板函数的int版本，即特化版本。</li></ol><h3 id="特化函数模板："><a href="#特化函数模板：" class="headerlink" title="特化函数模板："></a>特化函数模板：</h3><ol start="2"><li>显式特化格式为：template<code>&lt;&gt;</code> 返回类型函数名<code>&lt;要特化的类型&gt;</code>(参数列表) {函数体}，显式特化以template<code>&lt;&gt;</code>开头，表明要显式特化一个模板，在函数名后<code>&lt;&gt;</code>用尖括号括住要特化的类型版本。比如template <code>&lt;class T&gt;</code> void h(T a){}，其int 类型的特化版本为template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a){}，当出现int 类型的调用时就会调用这个特化版本，而不会调用通用的模板，比如h(2)，就会调用int 类型的特化版本。</li><li>如果可以从实参中推演出模板的形参，则可以省略掉显示模板实参的部分。比如：template<code>&lt;&gt;</code> void h(int a){}。注意函数h后面没有<code>&lt;&gt;</code>符号，即显式模板实参部分。</li><li>对于返回类型为模板形参时，调用该函数的特化版本必须要用显式模板实参调用，如果不这样的话就会出现其中一个形参无法推演的情况。如template<code>&lt;class T1,class T2,class T3&gt;</code> T1 h(T2 a,T3 b){}，有几种特化情况：<br>情况一：template<code>&lt;&gt;</code> int h<code>&lt;int,int&gt;</code>(int a, in b){}该情况下把T1，T2，T3的类型推演为int 型。在主函数中的调用方式应为h<code>&lt;int&gt;</code>(2,3)。<br>情况二：template<code>&lt;&gt;</code> int h(int a, int b){}，这里把T2,T3推演为int 型，而T1为int 型，但在调用时必须用显式模板实参调用，且在<code>&lt;&gt;</code>尖括号内必须指定为int 型，不然就会调用到通用函数模板，如h<code>&lt;int&gt;</code>(2,3)就会调用函数模板的特化版本，而h(2,3)调用会出错。h<code>&lt;double&gt;</code>(2,3)调用则会调用到通用的函数模板版本。<br>这几种情况的特化版本是错误的，如template<code>&lt;&gt;</code> T1 h(int a,int b){}，这种情况下T1会成为不能识别的名字，因而出现错误，template<code>&lt;&gt;</code> int h<code>&lt;double&gt;</code>(int a,int b){}在这种情况下返回类型为int 型，把T1确定为int 而尖括号内又把T1确定为double型，这样就出现了冲突。</li><li>具有相同名字和相同数量返回类型的非模板函数(即普通函数)，也是函数模板特化的一种情况，这种情况将在后面参数匹配问题时讲解。</li></ol><h3 id="特化类模板："><a href="#特化类模板：" class="headerlink" title="特化类模板："></a>特化类模板：</h3><ol start="6"><li>特化整个类模板：比如有template<code>&lt;class T1,class T2&gt;</code> class A{};其特化形式为template<code>&lt;&gt;</code> class A<code>&lt;int, int&gt;</code>{};特化形式以template<code>&lt;&gt;</code>开始，这和模板函数的形式相同，在类名A后跟上要特化的类型。</li><li>在类特化的外部定义成员的方法：比如template<code>&lt;class T&gt;</code> class A{public: void h();};类A特化为template<code>&lt;&gt;</code> class A<code>&lt;int&gt;</code>{public: void h();};在类外定义特化的类的成员函数h的方法为：void A<code>&lt;int&gt;</code>::h(){}。在外部定义类特化的成员时应省略掉template<code>&lt;&gt;</code>。</li><li>类的特化版本应与类模板版本有相同的成员定义，如果不相同的话那么当类特化的对象访问到类模板的成员时就会出错。因为当调用类的特化版本创建实例时创建的是特化版本的实例，不会创建类模板的实例，特化版本如果和类的模板版本的成员不一样就有可能出现这种错误。比如：模板类A中有成员函数h()和f()，而特化的类A中没有定义成员函数f()，这时如果有一个特化的类的对象访问到模板类中的函数f()时就会出错，因为在特化类的实例中找不到这个成员。</li><li>类模板的部分特化：比如有类模板template<code>&lt;class T1, class T2&gt;</code> class A{};则部分特化的格式为template<code>&lt;class T1&gt;</code> class A<code>&lt;T1, int&gt;</code>{};将模板形参T2特化为int 型，T1保持不变。部分特化以template开始，在<code>&lt;&gt;</code>中的模板形参是不用特化的模板形参，在类名A后面跟上要特化的类型。如果要特化第一个模板形参T1，则格式为template<code>&lt;class T2&gt;</code> class A<code>&lt;int, T2&gt;</code>{};部分特化的另一用法是template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,T1&gt;</code>{};将模板形参T2也特化为模板形参T1的类型。</li><li>在类部分特化的外面定义类成员的方法：比如有部分特化类template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,int&gt;</code>{public: void h();};则在类外定义的形式为template<code>&lt;class T1&gt;</code> void A<code>&lt;T1,int&gt;</code>::h(){}。注意当在类外面定义类的成员时template 后面的模板形参应与要定义的类的模板形参一样，这里就与部分特化的类A的一样template<code>&lt;class T1&gt;</code>。</li></ol><p>其他说明：<br>11. 可以对模板的特化版本只进行声明，而不定义。比如template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a);注意，声明时后面有个分号。<br>12. 在调用模板实例之前必须要先对特化的模板进行声明或定义。一个程序不允许同一模板实参集的同一模板既有显式特化又有实例化。比如有模板template<code>&lt;class T&gt;</code> void h(T a){}在h(2)之前没有声明该模板的int 型特化版本，而是在调用该模板后定义该模板的int 型特化版本，这时程序不会调用该模板的特化版本，而是调用该模板产生一个新的实例。这里就有一个问题，到底是调用由h(2)产生的实例版本呢还是调用程序中的特化版本。<br>13. 注意：因为模板的声明或定义不能在局部范围或函数内进行。所以特化类模板或函数模板都应在全局范围内进行。<br>14. 在特化版本中模板的类型形参是不可见的。比如template<code>&lt;&gt;</code> void h<code>&lt;int,int&gt;</code>(int a,int b){T1 a;}就会出现错误，在这里模板的类型形参T1在函数模板的特化版本中是不可见的，所以在这里T1是未知的标识符，是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板特化和类模板特化示例</span></span><br><span class="line"><span class="comment">//定义函数g1，g2和类A</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt; <span class="type">void</span> <span class="title">g1</span><span class="params">(T1 a,T2 b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;g1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="function">T1 <span class="title">g2</span><span class="params">(T2 a,T3 b)</span></span>&#123;  <span class="type">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="comment">//函数模板的特化定义。函数模板的特化可以理解为函数模板重载的另一种形式。</span></span><br><span class="line"><span class="comment">//下式为g1的类型形参显示指定其类型，把T1，T2在模板实参的尖括号中设为int型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">g1</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="type">int</span> a,<span class="type">int</span> b)&#123;cout&lt;&lt;<span class="string">&quot;g1一&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//下式显示设定g1的类型形参T1，并设为int型，T2由函数参数double推演为double型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">g1</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> a,<span class="type">double</span> b)&#123;cout&lt;&lt;<span class="string">&quot;g1二&quot;</span>&lt;&lt;endl;&#125;  </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">void</span> <span class="title">g1</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;g1三&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//g1的类型形参都由g1的形参推演出来。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void g1&lt;int&gt;(double a,int b)&#123;cout&lt;&lt;&quot;g•一&quot;&lt;&lt;endl;&#125;  //错误，在显示模板实参的尖括号中显示把类型形参T1的类型设为int型，而又在函数的形参中把类型形参T1的类型推演为double型，这样就发生了冲突，出现错误。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">int</span> <span class="built_in">g2</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="type">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2一&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">double</span> <span class="title">g2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="type">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2二&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="comment">//注意，下式正确，该式并不是对函数模板g2的部分特化，而是g2的重载。</span></span><br><span class="line"><span class="comment">//template&lt;class T2&gt; int g2(int a, T2 b)&#123;int c=1;cout&lt;&lt;&quot;g2三&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="comment">//下式错误，函数反回类型和&lt;double&gt;尖括号中的double类型不同，发生冲突。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; int g2&lt;double&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;two&quot;&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//下式错误，函数模板的类型形参在特化版本中是不可见的，也就是说这里的会把类型形参T1理解为未声明的标识符</span></span><br><span class="line"><span class="comment">//template&lt;&gt; T1 g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;two&quot;&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//类模板的特化和部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;<span class="comment">//特化整个类模板的格式，注意类名后的尖括号中必须指定所有的类模板的类型形参。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; class A&lt;int&gt;&#123;&#125;; //错误，在特化的类名后的尖括号中指定的类模板类型形参的数量不够。要想只特化其中一个类模板的类型形参，就要使用类模板的部分特化。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="keyword">class</span> <span class="title class_">A</span>&lt;T1,<span class="type">double</span>,T3&gt;&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;<span class="comment">//特化T2，而T1和T?不特化，注意尖括号中的类型形参是不特化的形参。</span></span><br><span class="line"><span class="comment">//在类模板的特化或部分特化版本的外部定义成员函数的方法。</span></span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A tehua&quot;</span>&lt;&lt;endl;&#125; <span class="comment">/*  T1 c; 错误，在特化版本中模板的类型形参是不可见的，也就是说在这里</span></span><br><span class="line"><span class="comment">T1是未声明的标识符。*/</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void A&lt;int,int,int&gt;::h()&#123;&#125; //错误，在类模板的特化版本外面定义类模板的成员时应省略掉template&lt;&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="type">void</span> A&lt;T1,<span class="type">double</span>,T3)::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A bute&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>&gt;<span class="type">void</span> A&lt;T1,T2,T3&gt;::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A putong&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//定义普通类模板中的成员函数。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//特化的函数模板的调用方式。</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//输出&quot;g1一&quot;，调用函数模板g1的第一个特化版本template&lt;&gt; void g1&lt;int,int&gt;(int a,int b)&#123;cout&lt;&lt;&quot;g1一&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">2</span>,<span class="number">3.2</span>); <span class="comment">//输出&quot;g1二&quot;，调用函数模板g1的第二个特化版本template&lt;&gt; void g1&lt;int&gt;(int a,double b)&#123;cout&lt;&lt;&quot;g1二&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">3.3</span>,<span class="number">4.4</span>); <span class="comment">//输出&quot;g1三&quot;，调用函数模板g1的第三个特化版本template&lt;&gt; void g1(double a,double b)&#123;cout&lt;&lt;&quot;g1三&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="built_in">g1</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>,<span class="number">2.3</span>);<span class="comment">//输出&quot;g1三&quot;，这里用显示模板实参把第一个实参指定为double型，这样g1的两个实参都是double型，所以将调用g1的第三个特化版本。</span></span><br><span class="line">    <span class="comment">//g2(3,3); 错误，在调用反回类型为类型形参的时候必须用显示模板实参的形式为反回类型的形参显示指定类型。在这里就会出现无法为T1确定类型的情况。</span></span><br><span class="line">    <span class="built_in">g2</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为int，调用g2的第一个特化版本。template&lt;&gt; int g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;g2一&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">    <span class="built_in">g2</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为double，调用g2的第二个特化版本。template&lt;&gt; double g2(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;g2二&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">    <span class="built_in">g2</span>&lt;<span class="type">char</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为char，对于char版本的g2函数没有特化版本，因此调用g2的通用版本。</span></span><br><span class="line">    <span class="comment">//    template&lt;class T1,class T2,class T3&gt;T1 g2(T2 a,T3 b) &#123;int c=1;cout&lt;&lt;&quot;g2&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">   <span class="comment">// 类模板特化和部分特化的调用。</span></span><br><span class="line">     A&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt; m1; m1.<span class="built_in">h</span>();<span class="comment">//正确，调用类模板的特化版本。</span></span><br><span class="line">     A&lt;<span class="type">int</span>,<span class="type">double</span>,<span class="type">int</span>&gt; m; m.<span class="built_in">h</span>(); <span class="comment">//正确，调用类模板的部分特化版本。</span></span><br><span class="line">           <span class="comment">//A&lt;int,int&gt; m2; //错误，类模板有三个类型形参，这里只提供了两个，数量不够，错误。</span></span><br><span class="line">     A&lt;<span class="type">double</span>,<span class="type">double</span>,<span class="type">int</span>&gt; m3; m3.<span class="built_in">h</span>();<span class="comment">//调用类A的部分特化版本。</span></span><br><span class="line">     A&lt;<span class="type">double</span>,<span class="type">int</span>,<span class="type">int</span>&gt; m4; m4.<span class="built_in">h</span>();<span class="comment">//调用类A的普通版本，在这里没有A&lt;double,int,int&gt;型的特化或者部分特化版本可用。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板重载（函数定制）："><a href="#函数模板重载（函数定制）：" class="headerlink" title="函数模板重载（函数定制）："></a>函数模板重载（函数定制）：</h3><ol><li>函数模板可以重载，注意类模板不存在重载问题，也就是说出现这两条语句时template<code>&lt;class  T&gt;</code>class A{};template<code>&lt;classT1,class T2&gt;</code>class A{};将出错。</li><li>模板函数重载的形式为：template<code>&lt;class T&gt;</code> void h(T a, int b){}。Template<code>&lt;class T&gt;</code>void h(T a, double b){}等。</li><li>重载模板函数要注意二义性问题，比如template<code>&lt;class T&gt;</code> void h(T a, int b){}和template<code>&lt;class T&gt;</code>void h(T a, T b){}这两个版本就存在二义性问题，当出现语句h(2,3)时就不知道调用哪个才正确，在程序中应避免这种情况出现。</li><li>重载函数模板的第二个二义性问题是template<code>&lt;class T&gt;</code>void h(T a, T b){}与template<code>&lt;class T1, class T2&gt;</code>void h(T1 a,T2 b){}，当出现h(2,4)这样的调用时就会出现二义性。解决这个问题的方法是使用显式模板实参，比如要调用第一个h函数，可以使用语法h<code>&lt;int&gt;</code>(2,3)，调用第二个h函数的方法为h<code>&lt;int, int&gt;</code>(2,3)。</li><li>函数模板的特化也可以理解为函数模板重载的一种形式。只是特化以template<code>&lt;&gt;</code>开始。</li><li>重载的特殊情况：比如template<code>&lt;class T1,class T2&gt;</code> void h(T1 a, T2 b){}，还有个版本如template<code>&lt;class T1&gt;</code>void h(T1 a, int b){}这里两个函数具有两同的名字和相同的形参数量，但形参的类型不同，可以认为第二个版本是第一个版本的重载版本。</li><li>函数模板的重载和特化很容易混淆，因为特化很像是一个函数的重载版本，只是开头以template<code>&lt;&gt;</code>开始而已。</li></ol><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p>在此之前我们来看看模板的形参。因为函数模板的参数相对比较简单，故将此内容放置于类模板中。模板形参有三种类型：类型形参、非类型形参和模板形参。先分别解释如下：</p><ul><li>类型形参。即由关键字class 或 typename后接的说明符构成，如template <code>&lt;class T&gt;</code>void function(T a);其中T就是类型形参。类型形参的名字由用户自定义，只要是合法的标识符即可。</li><li>非类型形参。模板的非类型形参也就是内置类型形参，如template<code>&lt;class T,int a&gt;</code>class B{};其中int a就是非类型形参。非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板内部是常量。使用非类型形参应注意以下几点：</li></ul><ol><li>非类型形参只能是整型、指针和引用。如：double,string,string **等都是不允许的，但是double &amp; ,double *是正确的。</li><li>调用非类型模板形参的实参必须是一个常量表达式，即在编译时就能确定其结果。任何局部对象、局部变量、局部变量地址、局部对象地址等都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型、全局变量、全局对象也不是一个常量表达式，不能用作非类型形参的实参。但全局变量的地址、全局对象的地址或应用const类型的变量时常量表达式，可用作非类型模板形参的实参。Sizeof表达式的结果也是一个常量表达式，同样也可以用作非类型模板形参的实参。如：Template <code>&lt;class T,int a&gt;</code>class A{};如果有int b，这时A<code>&lt;int,b&gt;</code> m;就会出错，因为b不是常量，如果有const int b;这时A<code>&lt;int ,b&gt;</code>就是正确的。</li><li>非类型形参一般不用于函数模板中。比如有函数模板template <code>&lt;class T,int a&gt;</code>void h(T,b){};若使用h(2)调用就会出错，无法为非类型形参a推演出参数的错误。对这种函数模板可以采用显示模板实参来解决，如h<code>&lt;int ,3&gt;</code>(2)，这样就把非类型形参a设置为整数3。显示模板参数将在后面介绍。</li><li>非类型模板形参和实参间允许转换。具体如下；<br>(1) 允许从数组到指针，从函数到指针的转换。如template <code>&lt;int *a&gt;</code>class A{};int c[1];A<code>&lt;c&gt;</code>m。<br>(2) Const修饰符的转换。如template <code>&lt;const int *a&gt;</code>class A{};int c;A<code>&lt;&amp;c&gt;</code>m;即从int * 到const int *的转换。<br>(3) 提升转换。如template <code>&lt;int a&gt;</code> class A{};const short c;A<code>&lt;c&gt;</code>m;即从short到int的提升转换。<br>(4) 整值转换。如template <code>&lt;unsigned int a&gt;</code> class A{};A<code>&lt;3&gt;</code> m;即从int到unsigned int的转换。</li></ol><ul><li>可以为类模板的类型形参提供默认值，但不能为函数模板的类型形参提供默认值。函数模板和类模板都可以为模板的非类型形参提供默认值。如template <code>&lt;class T1,class T2=int&gt;</code>class A{};为第二个模板类型形参提供int型的默认值。</li><li>类模板的类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个设定了默认值之后所以的模板形参都应设定默认值。如template <code>&lt;class T1=int,class T2&gt;</code>class D{};就是错误的，因为没有给T2设定默认值。但在外部定义类中的成员时，应省去默认的形参类型。如template <code>&lt;class T1,class T2=int&gt;</code>class A{public:void H();};定义方法是template <code>&lt;class T1,class T2&gt;</code>void A<code>&lt;T1,T2&gt;</code>::H(){};</li></ul><p>现将以上小节总结于以下一例，并通过vs2010调试，请读者仔细相关知识点的应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</span></span><br><span class="line"><span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:<span class="function">T <span class="title">g</span><span class="params">(T a, T b)</span></span>; <span class="built_in">A</span>();&#125;;  <span class="comment">//定义带有一个类模板类型形参T的类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义带有两个类模板类型形参T1，T2的类B</span></span><br><span class="line"><span class="comment">//定义类模板的默认类型形参，默认类型形参不适合于函数模板。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>=<span class="type">int</span>&gt; <span class="keyword">class</span> D&#123;<span class="keyword">public</span>: <span class="type">void</span> <span class="built_in">g</span>();&#125;; <span class="comment">//定义带默认类型形参的类模板。这里把T2默认设置为int型。</span></span><br><span class="line"><span class="comment">//template&lt;class T1=int, class T2&gt;class E&#123;&#125;; //错误，为T1设了默认类型形参则T1后面的所有形参都必须设置认默值。</span></span><br><span class="line"><span class="comment">//以下为非类型形参的定义</span></span><br><span class="line"><span class="comment">//非类型形参只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。但是double &amp;，double *对象的引用或指针是正确的。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> a&gt; <span class="keyword">class</span> <span class="title class_">Ci</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的非类型形参，形参为整型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> &amp;a&gt;<span class="keyword">class</span> <span class="title class_">Cip</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,A&lt;<span class="type">int</span>&gt;* m&gt; <span class="keyword">class</span> <span class="title class_">Cc</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的模板类型形参，形参为int型的类A的对象的指针。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">double</span>*a&gt;<span class="keyword">class</span> <span class="title class_">Cd</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;  <span class="comment">//定义模板的非类型形参，形参为double类型的引用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;&#125;; <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,E &amp;m&gt; <span class="keyword">class</span> <span class="title class_">Ce</span>&#123;&#125;; <span class="comment">//非类型模板形参为对象的引用。</span></span><br><span class="line"><span class="comment">//以下非类型形参的声明是错误的。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A m&gt;class Cc&#123;&#125;; //错误，对象不能做为非类型形参，非类型模板形参的类型只能是对象的引用或指针。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,double a&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是double类型，可以是double的引用。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A&lt;int&gt; m&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是对象，必须是对象的引用或指针。这条规则对于模板型参也不例外。</span></span><br><span class="line"><span class="comment">//在类模板外部定义各种类成员的方法，</span></span><br><span class="line"><span class="comment">//typeid(变量名).name()的作用是提取变量名的类型，如int a，则cout&lt;&lt;typeid(a).name()将输出int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   A&lt;T&gt;::<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A goucao&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125; <span class="comment">//在类模板外部定义类的构造函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T A&lt;T&gt;::<span class="built_in">g</span>(T a,T b)&#123;cout&lt;&lt;<span class="string">&quot;class A g(T a,T b)&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//在类模板外部定义类模板的成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;  <span class="type">void</span> B&lt;T1,T2&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class g f()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in">typeid</span>(T2).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> a&gt;     <span class="type">void</span> Ci&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Ci g()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> &amp;a&gt;    <span class="type">void</span> Cip&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cip g()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125; </span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template后的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,A&lt;<span class="type">int</span>&gt; *m&gt; <span class="type">void</span> Cc&lt;T1,m&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cc g()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">double</span>* a&gt; <span class="type">void</span> Cd&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cd g()&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//带有默认类型形参的模板类，在类的外部定义成员的方法。</span></span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template的形参表中默认值应省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;  <span class="type">void</span> D&lt;T1,T2&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class D g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void D&lt;T1,T2&gt;::g()&#123;cout&lt;&lt;&quot;class D k()&quot;&lt;&lt;endl;&#125; //错误，在类模板外部定义带有默认类型的形参时，在template的形参表中默认值应省略。</span></span><br><span class="line"><span class="comment">//定义一些全局变量。</span></span><br><span class="line"><span class="type">int</span> e=<span class="number">2</span>;  <span class="type">double</span> ed=<span class="number">2.2</span>; <span class="type">double</span>*pe=&amp;ed;</span><br><span class="line">A&lt;<span class="type">int</span>&gt; mw; A&lt;<span class="type">int</span>&gt; *pec=&amp;mw; E me;</span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line">    <span class="comment">//A&lt;2&gt; m; //错误，对类模板不存在实参推演问题，类模板必须在尖括号中明确指出其类型。</span></span><br><span class="line">    <span class="comment">//类模板调用实例</span></span><br><span class="line">    A&lt;<span class="type">int</span>&gt; ma; <span class="comment">//输出&quot;class A goucao int&quot;创建int型的类模板A的对象ma。</span></span><br><span class="line">    B&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mb; mb.<span class="built_in">g</span>(); <span class="comment">//输出&quot;class B g() int int&quot;创建类模板B的对象mb，并把类型形参T1和T2设计为int</span></span><br><span class="line">    <span class="comment">//非类型形参的调用</span></span><br><span class="line">    <span class="comment">//调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。任何局部对象，局部变量，局部对象的地址，局部</span></span><br><span class="line">    <span class="comment">//变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能</span></span><br><span class="line">    <span class="comment">//用作非类型模板形参的实参。</span></span><br><span class="line">    <span class="comment">//全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</span></span><br><span class="line">    <span class="comment">//调用整型int型非类型形参的方法为名为Ci，声明形式为template&lt;class T1,int a&gt; class Ci        Ci&lt;int,GHIJKLMJKLNOPQMII//正确，数值R是一个int型常量，输出&quot;class Ci g() int&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a2=<span class="number">3</span>;Ci&lt;<span class="type">int</span>,a2&gt; mci1; mci1.<span class="built_in">g</span>(); <span class="comment">//正确，因为a2在这里是const型的常量。输出&quot;class Ci g() int&quot;</span></span><br><span class="line">    <span class="comment">//Ci&lt;int,a&gt; mci; //错误，int型变量a是局部变量，不是一个常量表达式。</span></span><br><span class="line">    <span class="comment">//Ci&lt;int,e&gt; mci; //错误，全局int型变量e也不是一个常量表达式。</span></span><br><span class="line">    <span class="comment">//调用int&amp;型非类型形参的方法类名为Cip，声明形式为template&lt;class T1,int &amp;a&gt;class Cip</span></span><br><span class="line">    Cip&lt;<span class="type">int</span>,e&gt; mcip;  <span class="comment">//正确，对全局变量的引用或地址是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cip&lt;int,a&gt; mcip1; //错误，局部变量的引用或地址不是常量表达式。</span></span><br><span class="line">    <span class="comment">//调用double*类型的非类形形参类名为Cd，声明形式为template&lt;class T1,double *a&gt;class Cd</span></span><br><span class="line">    Cd&lt;<span class="type">int</span>,&amp;ed&gt; mcd; <span class="comment">//正确，全局变量的引用或地址是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cd&lt;int,pe&gt; mcd1; //错误，全局变量指针不是常量表达式。</span></span><br><span class="line">    <span class="comment">//double dd=aNGMIITbULcdefbbHIJKbgMIhh错误，局部变量的地址不是常量表达式，不能用作非类型形参的实参</span></span><br><span class="line">    <span class="comment">//Cd&lt;int,&amp;e&gt; mcd;  //错误，非类型形参虽允许一些转换，但这个转换不能实现。</span></span><br><span class="line">    <span class="comment">//调用模板类型形参对象A&lt;int&gt; *的方法类名为Cc，声名形式为template&lt;class T1,A&lt;int&gt;* m&gt; class Cc</span></span><br><span class="line">    Cc&lt;<span class="type">int</span>,&amp;mw&gt; mcc; mcc.<span class="built_in">g</span>(); <span class="comment">//正确，全局对象的地址或者引用是常量表达式</span></span><br><span class="line">    <span class="comment">//Cc&lt;int,&amp;ma&gt; mcc;  //错误，局部变量的地址或引用不是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cc&lt;int,pec&gt; mcc2;  //错误，全局对象的指针不是常量表达式。</span></span><br><span class="line">    <span class="comment">//调用非类型形参E&amp;对象的引用的方法类名为Ce。声明形式为template&lt;class T1,E &amp;m&gt; class Ce</span></span><br><span class="line">    E me1; <span class="comment">//Ce&lt;int,me1&gt; mce1; //错误，局部对象不是常量表达式</span></span><br><span class="line">    Ce&lt;<span class="type">int</span>,me&gt; mce;  <span class="comment">//正确，全局对象的指针或引用是常量表达式。</span></span><br><span class="line">    <span class="comment">//非类型形参的转换示例，类名为Ci</span></span><br><span class="line">    <span class="comment">//非类型形参允许从数组到指针，从函数到指针的转换，const修饰符的转换，提升转换，整值转换，常规转换。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">short</span> s=<span class="number">3</span> ;Ci&lt;<span class="type">int</span>,s&gt; mci ;<span class="comment">//正确，虽然short型和int不完全匹配，但这里可以将short型转换为int型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与函数模板相同，类模板的声明语句也必须至于类声明的前面。有两个以上模板参数时，应使用逗号分开。使用含类模板的类定义对象时也必须在类名的后面带上“﹤实际类型﹥”的参数列表。类模板最常用于各种类包容关系的设计模型中。</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Template ﹤类型参数表﹥ class 类名 {类声明体}</p><p>在使用类模板时，应注意以下几点：</p><ul><li>在所有出现类模板的地方不能直接用类名表示，都应加上﹤…﹥</li><li>在类模板定义体中，可以省略﹤…﹥</li><li>一个类模板的各个实例之间没有特殊的联系（形成一个独立的类）如：Queue<code>&lt;int&gt;</code> qi 和Queue<code>&lt;string&gt;</code> qs，分别表示整数队列和字符队列</li><li>实例化时机：在需要时实例化，比如定义指针或引用是不需要实例化，定义具体的变量或常量时会实例化，而访问对象的成员时会实例化。如 Queue<code>&lt;int&gt;</code> *q &#x2F;&#x2F;不实例化Queue<code>&lt;&gt;</code> ,Queue<code>&lt;int&gt;</code> iq &#x2F;&#x2F;实例化Queue<code>&lt;&gt;</code>，iq-&gt;<code>add(2) //实例化Queue</code>&lt;&gt;&#96;</li><li>类模板的显式实例化：和函数模板的显式实例化一样都是以template开始。比如template class A<code>&lt;int,int&gt;</code>;将类A显式实例化为两个int型的类模板。这里要注意显式实例化后面不能有对象名，且以分号结束。显式实例化可以让程序员控制模板实例化发生的时间。</li></ul><h2 id="类模板中的友元："><a href="#类模板中的友元：" class="headerlink" title="类模板中的友元："></a>类模板中的友元：</h2><ul><li><p>非模板函数、类成为所有实例类的友元。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Foo &#123; <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;&#125;;</span><br><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Class QueueItem</span><br><span class="line">&#123;</span><br><span class="line">         Friend <span class="keyword">class</span> <span class="title class_">Foobar</span>;  <span class="comment">//类Foobar不需要先定义或声明，并没有&lt;&gt;</span></span><br><span class="line">         <span class="function">Frined <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;    <span class="comment">//函数foo（）</span></span><br><span class="line">         <span class="function">Frined <span class="type">void</span> <span class="title">Foo::bar</span><span class="params">()</span></span>;<span class="comment">//类Foo必须先定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板函数、模板类成为同类型实例类的友元。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;…&#125;;</span><br><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>;</span><br><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">Queue</span>&#123; <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;&#125;;</span><br><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">QueueItem</span></span><br><span class="line">&#123;</span><br><span class="line">         Friend <span class="keyword">class</span> <span class="title class_">Foo</span>&lt;Type&gt;;  <span class="comment">//模板类Foo需要先定义或声明，并带有&lt;&gt;</span></span><br><span class="line">         <span class="function">Friend <span class="type">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>; <span class="comment">//模板函数foo()需要先定义或声明</span></span><br><span class="line">         Friend <span class="type">void</span> Queue&lt;Type&gt;::<span class="built_in">bar</span>();   <span class="comment">//模板类Queue必须先定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板函数、模板类成为不同类型实例类的友元。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">QueueItem</span></span><br><span class="line">&#123;</span><br><span class="line">         Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Foo</span>;</span><br><span class="line">         Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>;</span><br><span class="line">         Template &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Queue::bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板中有普通友元函数，友元类，模板友元函数和友元类。</p></li><li><p>可以建立两种类模板的友元模板，即约束型的友元模板和非约束型的友元模板。</p></li><li><p>非约束型友元模板：即类模板的友元模板类或者友元模板函数的任一实例都是外围类的任一实例的友元，也就是外围类和友元模板类或友元模板函数之间是多对多的关系</p></li><li><p>约束型友元模板：即类模板的友元模板类或友元模板函数的一个特定实例只是外围类的相关的一个实例的友元。即外围类和友元模板类或友元模板函数之间是一对一的关系。</p></li><li><p>约束型友元模板函数或友元类的建立：比如有前向声明：template<code>&lt;class T1&gt;</code> void g(T1 a); template<code>&lt;class T2&gt;</code> void g1(); template<code>&lt;class T3&gt;</code>class B;则template<code>&lt;class T&gt;</code>class A{friend void g<code>&lt;&gt;</code>(T a); friend void g1<code>&lt;T&gt;</code>(); friend class B<code>&lt;T&gt;</code>;};就建立了三个约束型友元模板，其中g和g1是函数，而B是类。注意其中的语法。这里g<code>&lt;int&gt;</code>型和类A<code>&lt;int&gt;</code>型是一对一的友元关系，g<code>&lt;double&gt;</code>和A<code>&lt;double&gt;</code>是一个一对一的友元关系。</p></li><li><p>非约束型友元模板函数或友元类的建立：非约束型友元模板和外围类具有不同的模板形参，比如template<code>&lt;class T&gt;</code>class A{template<code>&lt;class T1&gt;</code> friend void g(T1 a); template<code>&lt;class T2&gt;</code> friend class B;}注意其中的语法，非约束型友元模板都要以template开头。要注意友元模板类，在类名B的后面没有尖括号。</p></li><li><p>不存在部分约束型的友元模板或者友元类：比如template<code>&lt;class T&gt;</code> class A{template<code>&lt;class T1&gt;</code>friend void g(T1 a, T b);<br>template<code>&lt;class T3&gt;</code>friend class B<code>&lt;T3,T&gt;</code>;}其中函数g具有template<code>&lt;class T1,class T2&gt;</code>void g(T1 a,T2 b)的形式。其中的函数g试图把第二个模板形参部分约束为类A的模板形参类型，但是这是无效的，这种语法的结果是g函数的非约束型类友元函数，而对类B的友元声明则是一种语法错误。</p></li></ul><h2 id="类模板中的模板成员-模板函数-模板类-和静态成员"><a href="#类模板中的模板成员-模板函数-模板类-和静态成员" class="headerlink" title="类模板中的模板成员(模板函数,模板类)和静态成员"></a>类模板中的模板成员(模板函数,模板类)和静态成员</h2><ol><li>类模板中的模板函数和模板类的声明：与普通模板的声明方式相同，即都是以template 开始</li><li>在类模板外定义类模板中的模板成员的方法：比如template<code>&lt;class T1&gt;</code> class A {public:template<code>&lt;class T2&gt;</code> class B; template<code>&lt;class T3&gt;</code> void g(T3 a);};则在类模板外定义模板成员的方法为,template<code>&lt;class  T1&gt;</code> template<code>&lt;class T2&gt;</code> class A<code>&lt;T1&gt;</code>::B{};定义模板函数的方法为：template<code>&lt;class T1&gt;</code> template<code>&lt;class T3&gt;</code> void A<code>&lt;T1&gt;</code>::g(T3 a){}其中第一个template指明外围类的模板形参，第二个template指定模板成员的模板形参，而作用域解析运算符指明是来自哪个类的成员。</li><li>实例化类模板的模板成员函数：比如上例中要实例化函数g()则方法为, A<code>&lt;int&gt;</code> m; m.g(2);这里外围类A的模板形参由尖括号中指出，而类中的模板函数的参数由整型值2推演出为int 型。</li><li>创建类模板中的模板成员类的对象的方法：比如上例中要创建模板成员类B的方法为，A<code>&lt;int&gt;</code>::B<code>&lt;int&gt;</code> m1；A<code>&lt;int&gt;</code>::B<code>&lt;doble&gt;</code>m2;  A<code>&lt;double&gt;</code>::B<code>&lt;int&gt;</code> m3;在类模板成员B的前面要使用作用域解析运算符以指定来自哪个外围类，并且在尖括号中要指定创建哪个外围类的实例的对象。这里说明在类模板中定义模板类成员时就意味意该外围模板类的一个实例比如int 实例将包含有多个模板成员类的实例。比如这里类A的int 实例就有两个模板成员类B的int 和double两个实例版本。</li><li>要访问类模板中的模板成员类的成员遵守嵌套类的规则，因为类模板中的模板成员类就是一个嵌套类。即外围类和嵌套类中的成员是相互独立的，要访问其中的成员只能通过嵌套类的指针，引用或对象的方式来访问。具体情况见嵌套类部分。</li><li>类模板中的静态成员是类模板的所有实例所共享的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:<span class="type">int</span> a,b; <span class="type">static</span> <span class="type">int</span> e;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt; <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T5,<span class="keyword">class</span> T6&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(T5 a,T6 b)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">gc</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class C gc()&quot;</span>&lt;&lt;endl;&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;putong g1()&quot;</span>&lt;&lt;endl;&#125; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&#125;<span class="keyword">class</span> <span class="title class_">A</span>&lt;T1,T2&gt;::B&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">gb</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;moban class B gb()&quot;</span>&lt;&lt;endl;&#125;&#125;</span><br><span class="line"><span class="comment">//在类模板外面定义类模板的模板成员类的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T5</span>,<span class="keyword">class</span> <span class="title class_">T6</span>&#125;<span class="type">void</span> A&lt;T1,T2&gt;::<span class="built_in">g</span>(T5 a,T6 b)&#123;cout&lt;&lt;<span class="string">&quot;moban g()&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//在类模板外面定义类模板的模板成员函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="type">int</span> A&lt;T1,T2&gt;::e=<span class="number">0</span>;<span class="comment">//在类模板外面定义静态成员的方法。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ma;</span><br><span class="line">    ma.<span class="built_in">g</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//创建模板类中模板成员函数的方法，在这里模板类A的模板形参被设为int，而模板成员函数的模板形参则由两个int型的整    数推演为int型。</span></span><br><span class="line">    ma.e=<span class="number">1</span>; A&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::e=<span class="number">2</span>;  <span class="comment">//把类模板A的int,int型实例的静态成员设为。</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ma.e=&quot;</span>&lt;&lt;ma.e&lt;&lt;endl; </span><br><span class="line">    A&lt;<span class="type">int</span>,<span class="type">double</span>&gt; ma1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ma.e=&quot;</span>&lt;&lt;ma1.e&lt;&lt;A&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::e&lt;&lt;A&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::e&lt;&lt;endl; <span class="comment">//因为类模板A的int,int型实例和int,double实例是两个实例，所以这里的静态常量e的值不是三个二。</span></span><br><span class="line">    A&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::B&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mb;  <span class="comment">//声明模板类中模板成员类的方法。</span></span><br><span class="line">    mb.<span class="built_in">gb</span>();<span class="comment">//调用嵌套类B的成员函数</span></span><br><span class="line">    <span class="comment">//mb.g(); //错误，函数g()是外围类的成员，嵌套类不能访问外围类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">简单模板实例，参数列表为基本类型：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;    T *ar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array</span>(<span class="type">int</span> c)&#123;ar=<span class="keyword">new</span> T[c];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,T x)</span></span>&#123;ar[n]=x;    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n)&#123;<span class="keyword">return</span> ar[n];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">array</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input every element&#x27;s value:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;:&#x27;</span>;  </span><br><span class="line">        cin&gt;&gt;array[i];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">类模板参数是类：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">j</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(A *x)&#123;j=x-&gt;j;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>!()&#123;cout&lt;&lt;<span class="string">&quot;J=&quot;</span>&lt;&lt;j&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">     T *x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> xa,T *p):<span class="built_in">i</span>(xa)&#123;x=<span class="keyword">new</span> <span class="built_in">T</span>(p);&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>!()&#123;cout&lt;&lt;<span class="string">&quot;I=&quot;</span>&lt;&lt;i&lt;&lt;endl;!*x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">//最后的显示结果为：</span></span><br><span class="line">    <span class="function">B&lt;A&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,&amp;a)</span></span>;  <span class="comment">//I=2</span></span><br><span class="line">    !b;           <span class="comment">//J=1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Typename的使用：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">typename</span> T::id i; <span class="comment">//如无typename看看情况如何</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            i.<span class="built_in">g</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">class</span> <span class="title class_">id</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">                    </span>&#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//Y y;</span></span><br><span class="line">    X&lt;Y&gt; xy; </span><br><span class="line">    xy.<span class="built_in">f</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Typename关键字告诉编译器把一个特殊的名字解释成一个类型，在下列情况下必须对一个name使用typename关键字：</p><ul><li>一个唯一的name（可以作为类型理解），嵌套在另一个类型中。</li><li>依赖于一个模板参数，就是说，模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时便会产生误解。</li></ul><p>在定义模板时，typename和class作用基本相同，至于二者的其他关系没有什么区别，仅是历史原因，typename仅是一个新生代。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">复杂的模板类实例：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">static</span> Student *ip;</span><br><span class="line">    Student *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;p=<span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> n);</span><br><span class="line">    <span class="function"><span class="type">static</span> Student* <span class="title">get_first</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ip;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_number</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;number;&#125;</span><br><span class="line">    <span class="function">Student* <span class="title">get_next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n)  <span class="comment">//依据学号的大小顺序将学生对象插入链表</span></span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip==<span class="literal">NULL</span>)ip=<span class="keyword">this</span>;  <span class="comment">//如果是第一个则使头指针指向该对象</span></span><br><span class="line">    <span class="keyword">else</span>&#123;Student *temp=ip;      </span><br><span class="line">    <span class="keyword">if</span>(n&lt;ip-&gt;number)&#123;ip=<span class="keyword">this</span>;p=temp;&#125;<span class="comment">//如学号小于第一个学生对象的学号则使头指针指向该对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n&lt;temp-&gt;p-&gt;number)</span><br><span class="line">            &#123;</span><br><span class="line">                p=temp-&gt;p;  <span class="comment">//链中间对象的插入</span></span><br><span class="line">                temp-&gt;p=<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;p-&gt;p==<span class="literal">NULL</span>)  <span class="comment">//最后一个链的插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;p-&gt;p=<span class="keyword">this</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;                    &#125;</span><br><span class="line">            temp=temp-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student* Student::ip=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    T *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Class</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">Class</span>(<span class="type">int</span> n):<span class="built_in">num</span>(n)&#123;p=<span class="literal">NULL</span>;&#125;</span><br><span class="line">       <span class="function">T* <span class="title">insert</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;p=<span class="keyword">new</span> <span class="built_in">T</span>(n);<span class="keyword">return</span> p;&#125;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">list_all_member</span><span class="params">(T* x)</span></span></span><br><span class="line"><span class="function">       </span>&#123;   T *temp=x;</span><br><span class="line">       <span class="keyword">while</span>(temp) &#123; cout&lt;&lt;temp-&gt;<span class="built_in">get_number</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>;temp=temp-&gt;<span class="built_in">get_next</span>();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Class&lt;Student&gt; <span class="title">x97x</span><span class="params">(<span class="number">9707</span>)</span></span>;</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">23</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">38</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">22</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">    x97x.<span class="built_in">list_all_member</span>(Student::<span class="built_in">get_first</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板根据参数的类型进行实例化"><a href="#模板根据参数的类型进行实例化" class="headerlink" title="模板根据参数的类型进行实例化"></a>模板根据参数的类型进行实例化</h2><p>现在来讨论模板安全：模板根据参数的类型进行实例化。因为通常事先不知道其具体类型，所以也无法确切知道将在哪儿产生异常。程序员需要知道程序在什么地方发生了异常。下面看一个简单的模板类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Class Wrapper</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">         <span class="built_in">Wrapper</span>()&#123;&#125;</span><br><span class="line">         <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">         <span class="function">T <span class="title">set</span><span class="params">(T <span class="type">const</span> &amp;value)</span></span>&#123;value_=value;&#125;</span><br><span class="line">Private:</span><br><span class="line">         T value_;</span><br><span class="line">         <span class="built_in">Wrapper</span>(Wrapper <span class="type">const</span> &amp;);</span><br><span class="line">         Wrapper &amp;<span class="keyword">operator</span>=(Wrapper <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例化过程很简单，如Wrapper <code>&lt;int&gt;</code> i；因为Wrapper <code>&lt;int&gt;</code>只接受int或其引用，所以不会触及异常，Wrapper <code>&lt;int&gt;</code>不抛异常，也没有直接或者间接调用任何可能抛异常的函数，因此Wrapper <code>&lt;int&gt;</code>是异常安全的。<br>现在再来看Wrapper<code>&lt;X&gt;</code>x,这里X是一个类。在这个定义里，编译器实例化了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;&gt; Class Wrapper&lt;X&gt;</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">         <span class="built_in">Wrapper</span>()&#123;&#125;</span><br><span class="line">         <span class="function">X <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">         <span class="function">X <span class="title">set</span><span class="params">(X <span class="type">const</span> &amp;value)</span></span>&#123;value_=value;&#125;</span><br><span class="line">Private:</span><br><span class="line">         T value_;</span><br><span class="line">         <span class="built_in">Wrapper</span>(Wrapper <span class="type">const</span> &amp;);</span><br><span class="line">         Wrapper &amp;<span class="keyword">operator</span>=(Wrapper <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在就有问题出现了：</p><ul><li>Wrapper<code>&lt;X&gt;</code> 包含了一个X的子对象。这个子对象需要构造，意味着调用X的构造函数，这个构造函数可能抛出异常。</li><li>Wrapper<code>&lt;X&gt;</code>::get()产生并返回了一个X的临时对象。为了这个临时对象，get()调用了X的拷贝构造函数，这个函数可能抛出异常。</li><li>Wrapper<code>&lt;X&gt;</code>::set()执行了表达式value_&#x3D;value，他实际上调用了X的赋值运算。这个运算可能抛出异常。</li></ul><p>可以看到，同样的模板和同样的语句，但其含义不同。由于这样的不确定性，我们需要采用保守策略：假设Wrapper会根据类来实例化，而这些类在其成员上没有进行异常规格申明，则他们可能抛出异常。<br>再假设Wrapper的异常规格申明承诺其成员不产生异常。至少必须在其成员上加上异常规格申明throw()，所以需要修补掉这些可能导致异常的地方：</p><ul><li>在Wrapper：：Wrapper()中构造value_的过程。</li><li>在Wrapper::get()中返回value_的过程。</li><li>在Wrapper::set()中队value_的赋值过程。</li></ul><p>另外，在违背throw()的异常规格申明是，还要处理std::unexpected.</p><p>再来看默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Wrapper</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try:<span class="built_in">T</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123;&#125;</span><br></pre></td></tr></table></figure><p>虽然看上去不错，但它不能工作，根据C++标准：对构造函数或析构函数上的function-try-block，当控制权到达了异常处理函数的结束点是，被捕获的异常被再次抛出。对于一般的函数，此时是函数返回，等同于没有返回值的return 语句，对于定了返回类型的函数此时的行为未定义。换句话说，上面的程序相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try: <span class="built_in">T</span> ()&#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123; <span class="keyword">throw</span>;&#125;</span><br></pre></td></tr></table></figure><p>这不是程序本来想要的结果，换成以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try: <span class="built_in">T</span> ()&#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123; <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure><p>但是它却违背了标准：如果在构造函数上的function-try-block的异常处理函数体中出现了return语句，则程序是病态的。最终：无法用function-try-block快来实现构造函数的接口安全。</p><ul><li>引申原则1：尽可能使用构造函数不抛异常的基类或成员子对象。</li><li>引申原则2：为了帮助别人实现原则1，不要从构造函数中抛出任何异常。</li></ul><p>其他方面的不再讨论，比如析构与关键字new等。总之，良好的设计必须满足以下两个原则：</p><ul><li>通过异常对象的存在来注视异常状态，并适当的做出反应。</li><li>确保创造和传播异常对象不会造成更大的破坏。</li></ul><p>最终代码的参考将如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">wrapper</span>()     <span class="keyword">throw</span>() : <span class="built_in">value_</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;    </span><br><span class="line">            value_ = <span class="keyword">new</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">wrapper</span>() <span class="keyword">throw</span>()</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">delete</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...)&#123;<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(value_)</span></span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(T &amp;value)</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">assign</span>(value, *value_);&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">set</span><span class="params">(T <span class="type">const</span> &amp;value)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">assign</span>(*value_, value);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">assign</span><span class="params">(T &amp;to, T <span class="type">const</span> &amp;from)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">error</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;to = from; &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123; error = <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    T *value_;</span><br><span class="line">    <span class="built_in">wrapper</span>(wrapper <span class="type">const</span> &amp;);</span><br><span class="line">    wrapper &amp;<span class="keyword">operator</span>=(wrapper <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">wrapper&lt;<span class="type">int</span>&gt; <span class="title">mywrapper</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>可以像使用普通类的方法来使用模板类，这一点毫无疑问，例如：可以继承、创建一个从现有模板继承过来的并已经初始化的模板。现在，我们来看看模板的继承，如果vector已经为你做了很多事，但你还想加入sort()的功能，则可用下面代码来扩充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SORTED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SORTED </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorted</span>:<span class="keyword">public</span> std::vector&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Sorted&lt;T&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="built_in">size</span>();i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">at</span>(j<span class="number">-1</span>)&gt;<span class="built_in">at</span>(j))</span><br><span class="line">            &#123;</span><br><span class="line">                T t=<span class="built_in">at</span>(j<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">at</span>(j<span class="number">-1</span>)=<span class="built_in">at</span>(j);</span><br><span class="line">                <span class="built_in">at</span>(j)=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">实现文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;123.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">char</span>* words[] = &#123;<span class="string">&quot;is&quot;</span>, <span class="string">&quot;running&quot;</span>, <span class="string">&quot;big&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;a&quot;</span>&#125;; </span><br><span class="line"><span class="type">char</span>* words2[] = &#123; <span class="string">&quot;this&quot;</span>, <span class="string">&quot;that&quot;</span>, <span class="string">&quot;theother&quot;</span> &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Sorted&lt;<span class="type">int</span>&gt; is; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">15</span>; i &gt;<span class="number">0</span>; i--)    is.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; is.<span class="built_in">size</span>(); l++)  cout &lt;&lt; is[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    is.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; is.<span class="built_in">size</span>(); l++) cout &lt;&lt; is[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    Sorted&lt;string*&gt; ss; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) ss.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">string</span>(words[i])); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i++) cout &lt;&lt; *ss[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    ss.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i++) cout &lt;&lt; *ss[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    Sorted&lt;<span class="type">char</span>*&gt; scp; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) scp.<span class="built_in">push_back</span>(words2[i]); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; scp.<span class="built_in">size</span>(); i++) cout &lt;&lt; scp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    scp.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; scp.<span class="built_in">size</span>(); i++) cout &lt;&lt; scp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上简单实现了模板的继承，读者可自行编写相关代码进行测试，并分析模板继承情况下，析构函数和构造函数等的消坏和初始化情况，这里不这讨论。</p><p>注意：子类并不会从通用的模板基类继承而来，只能是从基类的某一个实例继承而来。</p><p>现将模板的继承方式总结以下几点：</p><ul><li>基类是模板类的一个特定实例化的版本。比如：template <code>&lt;class T1&gt;</code> class B:public A<code>&lt;int&gt;</code>{}.</li><li>基类是一个和子类相关的一个实例。比如：template <code>&lt;class T1&gt;</code>class B:public A<code>&lt;T1&gt;</code>{}。这时实例化基类就相应的被实例化一个和基类相同的实例版本，比如：B<code>&lt;int&gt;</code> b;模板B被实例化为int 版本，这时基类A也相应的被实例化为Int版本。</li><li>如果基类是一个特定的实例化版本，这时子类可以不是一个模板，比如：class B:public A<code>&lt;int&gt;</code>{};。</li></ul><p>每次实例化一个模板，模板的代码都会被重新生成（除了inline标记的函数），如果一个模板某些函数不依赖于特定的类型参数而存在，那它们就可以放置在一个通用的基础类中，来阻止无意义的代码重生。</p><p>Inline函数因不产生新的代码所以它们是自由的，在整个过程中，功能性的代码只是在我们创建基础类代码时产生了一次，而且，所属权的问题也因为增加了新的析构函数而解决。通常模板只有在需要的时候才实例化，对函数模板来说，这就意味着调用它时才被实例化，但对类模板来说，它更加明细化，只有在使用到模板中的某个函数式，函数才会被实例化，换句话说：只有用到的成员函数被实例化了。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">x</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This is fuction x()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">y</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This is fuction y()&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Z</span> </span><br><span class="line">&#123;</span><br><span class="line">    T t; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; t.<span class="built_in">x</span>(); &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; t.<span class="built_in">y</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Z&lt;X&gt; zx; </span><br><span class="line">    zx.<span class="built_in">a</span>(); <span class="comment">// Doesn&#x27;t create Z&lt;X&gt;::b() </span></span><br><span class="line">    Z&lt;Y&gt; zy; </span><br><span class="line">    zy.<span class="built_in">b</span>(); <span class="comment">// Doesn&#x27;t create Z&lt;Y&gt;::a()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用模板技术演示list的的使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template class for storing list elements</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                          <span class="comment">// Use template keyword</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListElement</span>                            <span class="comment">//定义类ListElement,用于表示list对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    ListElement&lt;T&gt; * next ;</span><br><span class="line">    <span class="built_in">ListElement</span>(T&amp; i_d, ListElement &lt;T&gt;* i_n)</span><br><span class="line">    : <span class="built_in">data</span>(i_d),<span class="built_in">next</span>(i_n) &#123; &#125;</span><br><span class="line">    <span class="function">ListElement&lt;T&gt;* <span class="title">copy</span><span class="params">()</span>                    <span class="comment">// copy includes all next elements</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListElement</span>(data,(next?next-&gt;<span class="built_in">copy</span>():<span class="number">0</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIterator</span>        <span class="comment">//定义类ListIterator,用于访问和操作list对象</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">                                            <span class="comment">//ListIterator(List&lt;T&gt;&amp; l) ;</span></span><br><span class="line">   <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>;</span><br><span class="line">   <span class="type">int</span> <span class="keyword">operator</span>++() ;</span><br><span class="line">   <span class="type">int</span> <span class="keyword">operator</span>!() ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     ListElement&lt;T&gt;* rep ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T ListIterator&lt;T&gt;::<span class="built_in">operator</span>() ()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (rep) <span class="keyword">return</span> rep-&gt;data;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T tmp ;    <span class="keyword">return</span> tmp ;                <span class="comment">// Default value  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> ListIterator&lt;T&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (rep)</span><br><span class="line">        rep = rep-&gt;next ;   </span><br><span class="line">    <span class="keyword">return</span> (rep != <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> ListIterator&lt;T&gt;::<span class="keyword">operator</span>!()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> (rep != <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>                <span class="comment">//定义类List </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ListIterator</span>&lt;T&gt; ;</span><br><span class="line">    <span class="built_in">List</span>();</span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp;);</span><br><span class="line">    ~<span class="built_in">List</span>();</span><br><span class="line">    List&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> List&lt;T&gt;&amp;);</span><br><span class="line">                                            <span class="comment">// typical list ops</span></span><br><span class="line">    <span class="function">T <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">tail</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="type">const</span> List&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>;                            <span class="comment">// Delete all list elements</span></span><br><span class="line">    ListElement&lt;T&gt;* rep ;</span><br><span class="line">&#125;;</span><br><span class="line">                                            <span class="comment">// Default Constructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt;::<span class="built_in">List</span>()&#123; rep = <span class="number">0</span> ; &#125;</span><br><span class="line">                                            <span class="comment">// Copy Constructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;List&lt;T&gt;::<span class="built_in">List</span>(<span class="type">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;     </span><br><span class="line">    rep = l.rep ? l.rep-&gt;<span class="built_in">copy</span>() : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Overloaded assignment operator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt;&amp; List&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rep != l.rep)   </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">clear</span>() ;        </span><br><span class="line">        rep = l.rep ? l.rep-&gt;<span class="built_in">copy</span>() : <span class="number">0</span> ;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt;::~<span class="built_in">List</span>()&#123;  <span class="built_in">clear</span>() ;&#125;</span><br><span class="line">                                            <span class="comment">// Delete representation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;   <span class="keyword">while</span> (rep)</span><br><span class="line">    &#123;   ListElement&lt;T&gt;* tmp = rep ;</span><br><span class="line">        rep = rep-&gt;next ;</span><br><span class="line">        <span class="keyword">delete</span> tmp ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Add element to front of list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">add</span>(T&amp; i)</span><br><span class="line">&#123;   </span><br><span class="line">    rep = <span class="keyword">new</span> <span class="built_in">ListElement</span>&lt;T&gt;(i,rep) ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Return head of list or default value of type T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T List&lt;T&gt;::<span class="built_in">head</span>()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (rep) <span class="keyword">return</span> rep-&gt;data ; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T tmp ; </span><br><span class="line">        <span class="keyword">return</span> tmp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Return tail of list or empty list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt; List&lt;T&gt;::<span class="built_in">tail</span>()</span><br><span class="line">&#123;    List&lt;T&gt; tmp ;</span><br><span class="line">     <span class="keyword">if</span> (rep)</span><br><span class="line">       <span class="keyword">if</span> (rep-&gt;next) tmp.rep = rep-&gt;next-&gt;<span class="built_in">copy</span>() ;</span><br><span class="line">     <span class="keyword">return</span> tmp ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Output operator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.rep)</span><br><span class="line">    &#123;</span><br><span class="line">        ListElement&lt;T&gt;* p = l.rep ;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;( &quot;</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p)&#123; os &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;   p = p-&gt;next ; &#125;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;)\n&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Empty list\n&quot;</span> ;</span><br><span class="line">    <span class="keyword">return</span> os ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   List&lt;<span class="type">int</span>&gt; l ;                            <span class="comment">// Integer list</span></span><br><span class="line">   cout &lt;&lt; l ;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   i=<span class="number">2</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   i=<span class="number">3</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;l is &quot;</span> &lt;&lt; l &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;head of l is &quot;</span> &lt;&lt; l.<span class="built_in">head</span>() &lt;&lt; endl ;</span><br><span class="line">   List&lt;<span class="type">int</span>&gt; m = l.<span class="built_in">tail</span>() ;</span><br><span class="line">   List&lt;<span class="type">int</span>&gt; o ;</span><br><span class="line">   o = m;</span><br><span class="line">   i=<span class="number">4</span>;</span><br><span class="line">   m.<span class="built_in">add</span>(i);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;m is &quot;</span> &lt;&lt; m &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;o is &quot;</span> &lt;&lt; o &lt;&lt; endl ;</span><br><span class="line">   List&lt;<span class="type">char</span>&gt; clist ;                        <span class="comment">// Character list</span></span><br><span class="line">   <span class="type">char</span> ch;</span><br><span class="line">   ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   clist.<span class="built_in">add</span>(ch);</span><br><span class="line">   ch=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   clist.<span class="built_in">add</span>(ch);</span><br><span class="line">   cout &lt;&lt; clist &lt;&lt; endl ;</span><br><span class="line">   List&lt;string&gt; ls ;                        <span class="comment">// string List</span></span><br><span class="line">   ls.<span class="built_in">add</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) ;</span><br><span class="line">   ls.<span class="built_in">add</span>(<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of strings&quot;</span> &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; ls &lt;&lt; endl ;</span><br><span class="line">   List&lt;List&lt;<span class="type">int</span>&gt; &gt; listlist ;                <span class="comment">// List of lists of integer. Notice that lists of lists are possible</span></span><br><span class="line">   listlist.<span class="built_in">add</span>(o) ;</span><br><span class="line">   listlist.<span class="built_in">add</span>(m) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of ints\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; listlist &lt;&lt; endl ;</span><br><span class="line">   List&lt;List&lt;List&lt;<span class="type">int</span>&gt; &gt; &gt; lllist ;            <span class="comment">// List of lists of lists of integer</span></span><br><span class="line">   lllist.<span class="built_in">add</span>(listlist) ;</span><br><span class="line">   lllist.<span class="built_in">add</span>(listlist) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of lists of ints\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; lllist &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line">   List&lt;List&lt;string&gt; &gt; slist ;               <span class="comment">// List of list of strings</span></span><br><span class="line">   slist.<span class="built_in">add</span>(ls) ;</span><br><span class="line">   slist.<span class="built_in">add</span>(ls) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of strings\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; slist &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以上某一个实例好像未通过调试，基于时间本人已忘记，读者发现后可查看相关情况自行更正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多进程处理数据</title>
      <link href="/2023/04/25/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/25/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程、多进程"><a href="#多线程、多进程" class="headerlink" title="多线程、多进程"></a>多线程、多进程</h1><p>进程(multiprocess)是操作系统资源分配（内存，显卡，磁盘）的最小单位，线程(Thread)是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程），一个进程可以有一个或多个线程，线程之间共享进程的资源。</p><p>cpu物理核数实际上是可以同时并行的线程数量，由于超线程技术，部分cpu实际上可以并行的线程数量通常是物理核数的两倍，这也是操作系统看到的核数。</p><p>处理任务可以分为计算密集型和IO密集型，假设使用一个进程来完成这个任务，对计算密集型任务，可以使用【<strong style="color:#00b050;">核心数</strong>】个线程，就可以占满cpu资源，进而可以充分利用cpu，如果再多，就会造成额外的开销；对于IO密集型任务（涉及到网络、磁盘IO的任务都是IO密集型任务），线程由于被IO阻塞，如果仍然用【核心数】个线程，cpu是跑不满的，于是可以使用<strong style="color:#00b050;">更多个线程</strong>来提高cpu使用率。</p><h1 id="python中的并行"><a href="#python中的并行" class="headerlink" title="python中的并行"></a>python中的并行</h1><p>对于其他语言，多核CPU支持多个线程同时执行。但在Python中，无论是单核还是多核cpu，一个进程同一时间只能由一个线程在执行。其根源是 <strong style="color:#00b050;">GIL（Global Interpreter Lock 全局解释器锁)</strong> 的存在。</p><p>设计原因：多线程会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，特别容易造成变量值的混乱，所以通过线程锁来限制线程的执行，保护数据安全。某个线程想要执行，必须先拿到 GIL，在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。所以多线程在python中是行不通的。python中的并行主要指的是进程并行，</p><p>通过调用 Python 自带的多进程库 <code>Multiprocessing</code>,可以轻松的在本地电脑上进行多核并行计算</p><h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>这个模块主要有以下两个部分：</p><h2 id="multiprocess-Process"><a href="#multiprocess-Process" class="headerlink" title="multiprocess.Process"></a>multiprocess.Process</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>multiprocess.Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><ul><li>group参数未使用，值始终为None</li><li>target表示调用对象，即子进程要执行的任务</li><li>args表示调用对象的位置参数元组，args&#x3D;(1,2,’egon’,)</li><li>kwargs表示调用对象的字典，kwargs&#x3D;{‘name’:’egon’,’age’:18}</li><li>name为子进程的名称</li></ul><p>注意：</p><ol><li>需要使用关键字的方式来指定参数</li><li>args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>p.start()：启动进程，并调用该子进程中的p.run()</li><li>p.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法</li><li>p.terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive()：如果p仍然运行，返回True</li><li>p.join([timeout])：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><h2 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool()"></a>multiprocessing.Pool()</h2><p>当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p><p>Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>multiprocessing.pool.Pool(processes&#x3D;None, initializer&#x3D;None, initargs&#x3D;(), maxtasksperchild&#x3D;None, context&#x3D;None)</p><h4 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h4><ul><li>processes — 进程池中进程数量，如果为 None，则使用 os.cpu_count() 返回的值</li><li>initializer — 如果该参数不为 None，则所有进程池中的进程启动时都会先执行 initializer(*initargs)</li><li>maxtasksperchild — 如果该参数不为 None，则进程在执行 maxtasksperchild 次任务后会被自动销毁、重启</li><li>context — 用于指定进程池中进程运行的上下文</li></ul><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li><p>1、apply() — 该函数用于传递不定参数，主进程会被阻塞直到函数执行结束（不建议使用，并且3.x以后不再出现），函数原型如下：</p></li><li><p>apply(func, args&#x3D;(), kwds&#x3D;{})</p></li><li><p>2、apply_async — 与apply用法一致，但它是非阻塞的且支持结果返回后进行回调，函数原型如下：</p></li><li><p>apply_async(func[, args&#x3D;()[, kwds&#x3D;{}[, callback&#x3D;None]]])</p></li><li><p>3、map() — Pool类中的map方法，与内置的map函数用法基本一致，它会使进程阻塞直到结果返回，函数原型如下：</p></li><li><p>map(func, iterable, chunksize&#x3D;None)</p></li><li><p>注意：虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。</p></li><li><p>4、map_async() — 与map用法一致，但是它是非阻塞的。其有关事项见apply_async，函数原型如下：</p></li><li><p>map_async(func, iterable, chunksize, callback)</p></li><li><p>5、close() — 关闭进程池（pool），使其不在接受新的任务。</p></li><li><p>6、terminal() — 结束工作进程，不在处理未处理的任务。</p></li><li><p>7、join() — 主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</p></li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我主要用多进程来处理数据、画图，下面是一个基本的模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_worker</span>(<span class="params">file_paths</span>):</span><br><span class="line">    <span class="comment"># 处理文件对应的路径的数据</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data.append(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">    plt.plot(data)</span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印进程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finishing&quot;</span>,Path(file_path).name) </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义错误回调函数，如果发生错误，能将错误在主进程中打印出来       </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error_callback</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)        </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将总数据集进行分割，分割成子数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_split</span>(<span class="params">path,batch_num</span>):</span><br><span class="line">  pathlist = <span class="built_in">list</span>(Path(path).glob(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">  <span class="comment"># 数据集长度</span></span><br><span class="line">  Len_path = <span class="built_in">len</span>(pathlist)            </span><br><span class="line">  param_dict =&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 数据分割</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> Len_path &lt;= batch_num:</span><br><span class="line">    batch_num = Len_path    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_num):</span><br><span class="line">    task = <span class="string">&quot;task&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    param_dict[task] = [(pathlist[i])]</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> Len_path &gt;= batch_num:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_num,Len_path):</span><br><span class="line">      task = <span class="string">&quot;task&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(i%batch_num))</span><br><span class="line">      param_dict[task].append(pathlist[i])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> param_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_t = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 查看cpu核数</span></span><br><span class="line">    num_cores = <span class="built_in">int</span>(mp.cpu_count())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本地计算机有: &quot;</span> + <span class="built_in">str</span>(num_cores) + <span class="string">&quot; 核心&quot;</span>)</span><br><span class="line">    <span class="comment"># 开启核核数相等的进程数目</span></span><br><span class="line">    <span class="comment"># pool = mp.Pool(num_cores)    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 遍历读取当前文件夹下所有子文件夹,并且转化为列表,我这里只开启8个进程</span></span><br><span class="line">    batch_num = <span class="number">8</span></span><br><span class="line">    param_dict = task_split(Path.cwd(),batch_num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启多进程处理数据</span></span><br><span class="line">    pool = mp.Pool(batch_num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> param_dict.items():</span><br><span class="line">      pool.apply_async(single_worker, args=(param,),error_callback=error_callback)</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 关闭进程池</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    end_t = datetime.datetime.now()</span><br><span class="line">    elapsed_sec = (end_t - start_t).total_seconds()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;多进程计算 共消耗: &quot;</span> + <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(elapsed_sec) + <span class="string">&quot; 秒&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我处理10个结果，如果使用单进程需要20左右，开启8个进程，平均总时间能够减少到2s，多进程效果非常明显。</p><p>🌟注意：</p><p>必须把主进程写在「程序的入口」才能正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>这么做，能够避免重复执行主进程</p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://zhuanlan.zhihu.com/p/208996070">https://zhuanlan.zhihu.com/p/208996070</a></p><p><a href="https://zhuanlan.zhihu.com/p/103135242">https://zhuanlan.zhihu.com/p/103135242</a></p><p><a href="https://www.cnblogs.com/SkyOceanchen/p/11537587.html">https://www.cnblogs.com/SkyOceanchen/p/11537587.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/340965963">https://zhuanlan.zhihu.com/p/340965963</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> multiprocess </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python制作图片ppt</title>
      <link href="/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/"/>
      <url>/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>当需要有大量类似的图片结果需要分析的时候，一个一个插入ppt比较费时间，而且万一顺序错了就是灾难，python的Pillow库可以读取和操作图片，而python-pptx库可以创建PPT文件，非常方便。</p><h1 id="库安装"><a href="#库安装" class="headerlink" title="库安装"></a>库安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-pptx</span><br></pre></td></tr></table></figure><h1 id="单个目录"><a href="#单个目录" class="headerlink" title="单个目录"></a>单个目录</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.util <span class="keyword">import</span> Inches</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 创建一个新的PPT文件</span></span><br><span class="line">prs = Presentation()</span><br><span class="line"><span class="comment"># 图片文件夹路径</span></span><br><span class="line">img_folder = <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="comment"># 定义每页显示的图片数量</span></span><br><span class="line">pics_per_page = <span class="number">2</span></span><br><span class="line">prs = Presentation()</span><br><span class="line"><span class="comment"># 获取ppt大小</span></span><br><span class="line">width = prs.slide_width</span><br><span class="line">height = prs.slide_height</span><br><span class="line"><span class="comment"># 图片大小缩放</span></span><br><span class="line">rescale = <span class="number">1</span> </span><br><span class="line"><span class="comment"># width = Inches(6)</span></span><br><span class="line"><span class="comment"># height = Inches(4.5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹中的所有图片</span></span><br><span class="line">pic_files = <span class="built_in">sorted</span>(os.listdir(img_folder))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pic_files), pics_per_page):</span><br><span class="line">    <span class="comment"># 创建一个新的幻灯片</span></span><br><span class="line">    slide = prs.slides.add_slide(prs.slide_layouts[<span class="number">6</span>])</span><br><span class="line">    <span class="comment"># 在幻灯片中添加图片</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pics_per_page):</span><br><span class="line">        <span class="keyword">if</span> i + j &gt;= <span class="built_in">len</span>(pic_files):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 打开图片文件</span></span><br><span class="line">        img_path = os.path.join(img_folder, pic_files[i + j])</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        width_, height_ = img.size</span><br><span class="line">        <span class="comment"># 获取图片长高比例</span></span><br><span class="line">        ratio = height_ / width_</span><br><span class="line">        <span class="comment"># 计算图片在幻灯片中的位置和大小</span></span><br><span class="line">        <span class="comment"># left = Inches(j * 5)</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        top = j * height / <span class="number">2</span></span><br><span class="line">        width_rescale = width * rescale</span><br><span class="line">        height_rescale = width_rescale * ratio</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将图片添加到幻灯片中</span></span><br><span class="line">        pic = slide.shapes.add_picture(img_path, left, top, width=width_rescale, height=height_rescale)</span><br><span class="line"><span class="comment"># 保存PPT文件</span></span><br><span class="line">prs.save(<span class="string">&#x27;output.pptx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><p>这段代码首先创建了一个新的PPT文件，然后遍历指定文件夹中的所有图片文件。对于每两个图片文件，它创建一个新的幻灯片，并将两张图片添加到幻灯片中。最后，它将PPT文件保存到指定的输出文件中。请注意，这里使用了sorted()函数来确保图片按照文件名的字母顺序排序。</p><p>在幻灯片中，每张图片的宽和ppt大小保持一直，高度按照比例缩小，每张ppt上下排列两张图片，可以根据需要调整这些值。</p><p>add_picture后的四个参数分别为图片放置的左上坐标，以及宽度和高度，坐标如下：</p><p><img src="/2023/04/24/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87ppt/image-20230424155501482.png" alt="image-20230424155501482"></p><p>参数说明：</p><p>往右，left变大，往下，top变大</p><p>🌟注意： 图片的size为像素单位，注意和Inches之间的换算</p><h1 id="多个目录"><a href="#多个目录" class="headerlink" title="多个目录"></a>多个目录</h1><p>如果有多个目录，每个文件夹下面的图片单独保存到ppt中也非常简单，只需要再嵌套一层for循环，这里我使用了pathlib库<a href="https://zhuanlan.zhihu.com/p/139783331/">教程</a> ，操作路径比os库方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.util <span class="keyword">import</span> Inches</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片文件夹路径</span></span><br><span class="line">path= Path(<span class="string">&#x27;testFlag&#x27;</span>)</span><br><span class="line"><span class="comment"># 匹配子路径</span></span><br><span class="line">pathlists = <span class="built_in">list</span>(path.glob(<span class="string">&quot;Loop*&quot;</span>))</span><br><span class="line"><span class="comment"># 确认路径</span></span><br><span class="line">pprint(pathlists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img_folder <span class="keyword">in</span> pathlists:</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 创建一个新的PPT文件</span></span><br><span class="line">  prs = Presentation()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定义每页显示的图片数量</span></span><br><span class="line">  pics_per_page = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  prs = Presentation()</span><br><span class="line">  width = prs.slide_width</span><br><span class="line">  height = prs.slide_height</span><br><span class="line">  rescale = <span class="number">1</span> </span><br><span class="line">  <span class="comment"># width = Inches(6)</span></span><br><span class="line">  <span class="comment"># height = Inches(4.5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 遍历文件夹中的所有图片</span></span><br><span class="line">  pic_files = <span class="built_in">sorted</span>(img_folder.glob(<span class="string">&quot;*&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pic_files), pics_per_page):</span><br><span class="line">      <span class="comment"># 创建一个新的幻灯片</span></span><br><span class="line">      slide = prs.slides.add_slide(prs.slide_layouts[<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 在幻灯片中添加图片</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pics_per_page):</span><br><span class="line">          <span class="keyword">if</span> i + j &gt;= <span class="built_in">len</span>(pic_files):</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 打开图片文件</span></span><br><span class="line">          img_path = os.path.join(img_folder, pic_files[i + j])</span><br><span class="line">          img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">          width_, height_ = img.size</span><br><span class="line">          ratio = height_ / width_</span><br><span class="line"></span><br><span class="line">          <span class="comment"># 计算图片在幻灯片中的位置和大小</span></span><br><span class="line">          <span class="comment"># left = Inches(j * 5)</span></span><br><span class="line">          left = <span class="number">0</span></span><br><span class="line">          top = j * height / <span class="number">2</span> + Inches(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">          width_rescale = width * rescale</span><br><span class="line">          height_rescale = width_rescale * ratio</span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 将图片添加到幻灯片中</span></span><br><span class="line">          pic = slide.shapes.add_picture(img_path, left, top, width=width_rescale, height=height_rescale)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 保存PPT文件</span></span><br><span class="line">  prs.save(img_folder.parent.joinpath(img_folder.name +<span class="string">&quot;.pptx&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装onedrive</title>
      <link href="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/"/>
      <url>/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>onedrive作为一个能跨平台的云盘，使用起来特别香，最近还增加了增量备份、查看历史版本等功能，特别适合有多个设备、需要频繁传输数据的使用者。</p><p>我经常需要在Linux平台保存数据，将处理的结果传输到win平台上，所以在服务器上也安装了OneDrive，主要的原理是磁盘挂载，相当于起到“扩大”磁盘空间的作用。</p><p>以contos7为例，仓库链接：<a href="https://github.com/skilion/onedrive">onedrive</a></p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>需要的依赖：libcurl-devel，sqlite-devel, 编译工具dmd</p><p>如果有root权限，可以直接通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libcurl-devel</span><br><span class="line">sudo yum install sqlite-devel</span><br></pre></td></tr></table></figure><p>如果没有root权限，通过下载源代码编译，不过需要把这些动态库的路径添加到bashrc里面，具体可以参考<a href="https://www.jianshu.com/p/da92ca36a220/">无root权限下解决编译时的依赖问题</a> ：</p><p>安装有先后</p><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.0.2m.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2m.tar.gz &amp;&amp; cd openssl-1.0.2m</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加shared生成动态库</span></span><br><span class="line">./config --prefix=$HOME/usr shared</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">卸载使用 make clean</span><br></pre></td></tr></table></figure><h2 id="libssh2"><a href="#libssh2" class="headerlink" title="libssh2"></a>libssh2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.libssh2.org/download/libssh2-1.8.0.tar.gz</span><br><span class="line">tar -zxvf libssh2-1.8.0.tar.gz &amp;&amp; cd libssh2-1.8.0</span><br><span class="line">./configure --with-libssl-prefix=$HOME/usr/ssl --prefix=$HOME/usr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="libcurl"><a href="#libcurl" class="headerlink" title="libcurl"></a>libcurl</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://curl.haxx.se/download/curl-7.56.1.tar.gz</span><br><span class="line">tar -zxvf curl-7.56.1.tar.gz &amp;&amp; cd curl-7.56.1</span><br><span class="line">./configure --prefix=$HOME/usr --enable-http  --enable-https --enable-ftp --enable-file --enable-proxy --enable-telnet --enable-libcurl-option --enable-ipv6 --with-lib --with-ssl</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装成功后记得把路径加入到环境变量，</p><p>将以上内容加入到.bashrc中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PAHT=$LD_LIBRARY_PATH:$HOME/usr/lib64</span><br><span class="line">export LD_LIBRARY_PAHT=$LD_LIBRARY_PATH:$HOME/usr/lib</span><br><span class="line">export PKG_CONFIG_PATH=$HOME/usr/lib/pkgconfig:$HOME/usr/share/pkgconfig</span><br><span class="line">export PATH=$HOME/usr/bin:$PATH</span><br></pre></td></tr></table></figure><p>使设置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="最后安装dlang"><a href="#最后安装dlang" class="headerlink" title="最后安装dlang"></a>最后安装dlang</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlang.org/install.sh </span><br><span class="line">bash install.sh install dmd-2.080.0</span><br></pre></td></tr></table></figure><p>我安装的版本是dmd-2.080.0，安装最新的程序后面会报错</p><p>安装成功后：</p><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_1.8ec48fc8.png"></p><p>使用 <code>source ~/dlang/dmd-2.080.0/activate</code> 命令可进入环境</p><p>注意：onedrive安装过程在进入环境后才进行的，安装完再退出环境。</p><h1 id="安装onedrive"><a href="#安装onedrive" class="headerlink" title="安装onedrive"></a>安装onedrive</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/abraunegg/onedrive/archive/refs/tags/v2.3.4.tar.gz</span><br><span class="line">tar zxvf v2.3.4.tar.gz</span><br><span class="line">cd onedrive-2.3.4/</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>由于不是使用root命令安装, 所以需要修改makefile.in</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim makefile.in</span><br></pre></td></tr></table></figure><ol><li>加入日志文件路径</li></ol><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_2.49f672c6.png"></p><ol start="2"><li>更改用户</li></ol><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_3.1df847f1.png"></p><p>将此处的 -o root -g users 改成 -o 用户名，删除后面的-g users</p><p>并且将下一行的onedrive 后面的${DESDIR}删除</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=$HOME/usr &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完，用deactivate 退出环境</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>现在您需要向 Microsoft 授权 Onedrive，以便它可以访问您的帐户。在终端中输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/linux%E5%AE%89%E8%A3%85onedrive/image_4.c5e19314.png"></p><p>它会提示您访问该 URL 以获得授权。</p><p>复制此链接，在windows浏览器中打开，您将看到一个空白页面。复制 URL 并在提示符下将其粘贴到终端中。</p><p>登录您的 OneDrive 帐户，并复制此处的链接粘贴到终端。</p><p>完成以上步骤后，Onedrive 将开始将云中的所有文件下载到本地文件夹。</p><h2 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h2><p>您可以在 Onedrive git 文件夹中找到“config”文件。要激活，请将其移至 ~&#x2F;.config&#x2F;onedrive&#x2F;文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive/</span><br><span class="line">cp ~/onedrive/config ~/.config/onedrive/</span><br></pre></td></tr></table></figure><p>打开配置文件。您可以配置两个选项：“sync_dir”和“skip_files”。</p><p>sync_dir：存储 OneDrive 文件的位置。放置在此文件夹中&#x2F;从中删除的所有文件，都将同步到云端。</p><p>skip_files：不同步的文件类型（或文件模式）。</p><p>完成更改后，保存并重新启动 Onedrive。</p><p>具体配置请参考<a href="https://www.jianshu.com/p/017aa8ceef02/">linux onedrive配置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的matplotlib安装arial字体</title>
      <link href="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/"/>
      <url>/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>绘图中经常会使用Arial字体，linux服务器上默认是没有这个字体。为了省去每次修改字体的麻烦，在matplotlib中安装了这个字体，并且设置为matplotlib默认字体。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="复制字体至-matplotlib-库-fonts-x2F-ttf-目录"><a href="#复制字体至-matplotlib-库-fonts-x2F-ttf-目录" class="headerlink" title="复制字体至 matplotlib 库 fonts&#x2F;ttf 目录"></a>复制字体至 matplotlib 库 fonts&#x2F;ttf 目录</h2><p>windows上有Arial字体，在C:\Windows\Fonts 路径下，</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image_1.b2ef3533.png"></p><p>找到并且全部复制到linux服务器上matplotlib字体库下面，</p><p>路径为：python_envs_name &#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;fonts&#x2F;ttf</p><p><img src="/2023/04/23/linux%E7%9A%84matplotlib%E5%AE%89%E8%A3%85arial%E5%AD%97%E4%BD%93/image-20230423165253522.png" alt="image-20230423165253522"></p><h2 id="修改-matplotlib-库配置文件-matplotlibrc"><a href="#修改-matplotlib-库配置文件-matplotlibrc" class="headerlink" title="修改 matplotlib 库配置文件 matplotlibrc"></a>修改 matplotlib 库配置文件 matplotlibrc</h2><p>路径：env_name&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;matplotlib&#x2F;mpl-data&#x2F;matplotlibrc</p><p>打开后查找 font.family，将Arial加到最前面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.serif: Arial, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.sans-serif: Arial,DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.cursive: Apple Chancery, Textile, Zapf Chancery, Sand, Script MT, Felipa, Comic Neue, Comic Sans MS, cursive</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.fantasy: Chicago, Charcoal, Impact, Western, Humor Sans, xkcd, fantasy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">font.monospace: DejaVu Sans Mono, Bitstream Vera Sans Mono, Computer Modern Typewriter, Andale Mono, Nimbus Mono L, Courier New, Courier, Fixed, Terminal, monospace</span></span><br></pre></td></tr></table></figure><h2 id="清除-matplotlib-cache"><a href="#清除-matplotlib-cache" class="headerlink" title="清除 matplotlib cache"></a>清除 matplotlib cache</h2><p>需要清除原来的matplotlib缓存修改的字体才会生效，最直接的办法就是把缓存文件夹直接删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/User/.cache/matplotlib</span><br></pre></td></tr></table></figure><h1 id="字体说明"><a href="#字体说明" class="headerlink" title="字体说明"></a>字体说明</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">font.family : sans-serif</span><br><span class="line"></span><br><span class="line">font.sans-serif : SimHei</span><br><span class="line"></span><br><span class="line">axes.unicode_minus : <span class="literal">False</span></span><br></pre></td></tr></table></figure><ol><li><p><strong style="color:#00b0f0;">sans-serif</strong>：专指西文中无衬线的字体，与汉字字体中的黑体相对应。该类字体通常是机械的和统一线条的，它们往往拥有相同的曲率，笔直的线条，锐利的转角。这种字体当前系统中肯定存在，所以使用这个字体一定能显示出来，所以通过会加上sans-serif来保证调用。</p><p>常见的无衬线字体有 Trebuchet MS, Tahoma, Verdana, Arial, Helvetica, 中文的幼圆、隶书等等。</p><p>font-family最后加上sans-serif，也是为了保证能够调用这个字体族里面的字体，因为大多数计算机里都有这种字体。</p></li><li><p>其他字体</p></li></ol><ul><li><p>黑体：SimHei</p></li><li><p>宋体：SimSun</p></li><li><p>微软雅黑体：Microsoft YaHei</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell远程服务器本地可视化方法</title>
      <link href="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在大多数时候，我们连接的远程服务器没有图形界面，不能支持浏览器功能，这时我们需要建立本地服务器与远程服务器的通信。</p><p>以Tensorboard的本地可视化方法为例：</p><h1 id="不推荐："><a href="#不推荐：" class="headerlink" title="不推荐："></a>不推荐：</h1><p>网上常见的方法：</p><p>在本地计算机上，打开一个新的终端窗口，并使用以下命令创建一个SSH隧道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 6006:localhost:6006 username@remote\_server\_ip</span><br></pre></td></tr></table></figure><p>其中，username是您在远程服务器上的用户名，remote_server_ip是远程服务器的IP地址。</p><p>1.在远程服务器上启动TensorBoard：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=/path/to/logs</span><br></pre></td></tr></table></figure><p>2.找到TensorBoard启动时显示的URL，类似于以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TensorBoard 1.14.0 at [http://localhost:6006/](http://localhost:6006/) (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>3.在本地计算机上，打开Web浏览器并访问以下URL：</p><p><a href="http://localhost:6006/">http://localhost:6006</a></p><p>这个方法我尝试了多次，都不成功：</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_1.44605818.png"></p><p><strong style="color:#00b050;">可能windows电脑不适用</strong></p><h1 id="推荐方法：Xshell隧道"><a href="#推荐方法：Xshell隧道" class="headerlink" title="推荐方法：Xshell隧道"></a>推荐方法：Xshell隧道</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开Xshell，右击相应的会话，在弹出的对话框中选择属性-&gt;连接-&gt;SSH-&gt;隧道-&gt;添加。</p><p>在侦听端口和目标端口中填入相同的端口，此处填写了6006;（这里的端口号，也可以随便换成其他的，只要保证两处相同即可）。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_2.73d50b2e.png"></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>服务器端启动tensorboard</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensrboard --logdir=log地址 --port=6006</span><br></pre></td></tr></table></figure><p>本地浏览器查看</p><p>然后再本地浏览器中输入：<a href="http://127.0.0.1:6006/">http://127.0.0.1:6006</a> 或者localhost:6006，可以通过tensorboard查看目前的训练情况。</p><p><img src="/2023/04/23/Xshell%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/image_3.5e37b6bd.png"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/a314688122a/article/details/81505082">https://blog.csdn.net/a314688122a/article/details/81505082</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpirun运行参数</title>
      <link href="/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2023/04/20/mpirun%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对于mpirun运行参数存在疑问，<a href="https://www.cnblogs.com/devilmaycry812839668/p/15132333.html">转载来源</a></p><p>相关资料，参看前文：</p><p><a href="https://www.cnblogs.com/devilmaycry812839668/p/15107935.html">https://www.cnblogs.com/devilmaycry812839668/p/15107935.html</a></p><p>现有硬件：两台装有Ubuntu18.04的操作系统（下面简称A电脑，B电脑）</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>网络：</p><p>A、B电脑之间使用100M以太网交换机连接（就是TP-Link路由器）。</p><p>其中，A电脑IP为 192.168.11.66， B电脑IP为 192.168.11.206</p><p>本文中的代码   x.py  :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">size = comm.Get_size()</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line"> </span><br><span class="line">sendbuf = np.zeros(<span class="number">100</span>*<span class="number">10000</span>, dtype=<span class="string">&#x27;i&#x27;</span>) + rank</span><br><span class="line">recvbuf = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    recvbuf = np.empty([size, <span class="number">100</span>*<span class="number">10000</span>], dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( MPI.Get_processor_name() )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">a = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    comm.Gather(sendbuf, recvbuf, root=<span class="number">0</span>)</span><br><span class="line">b = time.time()</span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(b-a)</span><br></pre></td></tr></table></figure><p>本文所有的命令均为在主机A上执行，所以本文中对myhosts文件的编写都是在A主机下进行的。</p><h1 id="参数-–machinefile"><a href="#参数-–machinefile" class="headerlink" title="参数   –machinefile"></a>参数   –machinefile</h1><p>该参数主要是用在分布式环境下，在单机环境该参数没有意义。该参数就是指定分布式环境下有几台主机，并且可以指定每台主机最多可以开几个CPU进行计算。</p><p>具体命令:</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxx/anaconda3/bin/python x.py</code></p><p>其中， myhosts 为我们需要编写的文本文件，该文件指定mpi分布式环境下各个主机的IP及可以运行的最多CPU数。</p><p>myhosts文件最基本的设置就是不指定每个主机最多可以运行的CPU数，那么此时每台主机最多可以运行的CPU数为多少呢，这时每台主机最多可以运行的CPU数为该主机的物理CPU核心数，本文中主机A 192.168.11.66的最多可以运行CPU数为24， 主机B 192.168.11.206最多可以运行的CPU数为6。</p><p>最基本的 myhosts ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       </span><br><span class="line">192.168.11.206 </span><br></pre></td></tr></table></figure><p>myhosts中给出分布式环境下两个主机IP，此时每个主机最多可以使用的CPU数为物理核心个数。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示8个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，&#x3D;&#x3D;所有优先使用主机A的计算资源&#x3D;&#x3D;）。</p><p>执行命令：</p><p>`mpirun -np 24 –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果显示24个进程均运行在主机A上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>执行命令：</p><p><code>mpirun -np 25  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行25个进程，其中24个进程运行在主机A上， 一个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有一个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 30  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示共运行30个进程，其中24个进程运行在主机A上， 6个进程运行在主机B上 （因为运行命令本身就是在主机A上运行的，所有优先使用主机A的计算资源）。</p><p>因为主机A最多可以利用的CPU个数为24，所以需要有6个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 31  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the <span class="number">31</span></span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/<span class="built_in">bin</span>/python</span><br><span class="line">Either request fewer slots foryour application, <span class="keyword">or</span> make more slots</span><br><span class="line">available <span class="keyword">for</span> use.</span><br><span class="line">A <span class="string">&quot;slot&quot;</span>isthe Open MPI term <span class="keyword">for</span> an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment <span class="keyword">in</span> which Open MPI processes are run:</span><br><span class="line"><span class="number">1.</span> Hostfile, via <span class="string">&quot;slots=N&quot;</span> clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  <span class="number">2.</span> The --host command line parameter, via a <span class="string">&quot;:N&quot;</span> suffix on the</span><br><span class="line">     hostname (N defaults to <span class="number">1</span> ifnot provided)</span><br><span class="line">  <span class="number">3.</span> Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  <span class="number">4.</span> If none of a hostfile, the --host command line parameter, <span class="keyword">or</span> an</span><br><span class="line">     RM <span class="keyword">is</span> present, Open MPI defaults to the number of processor cores</span><br><span class="line">In <span class="built_in">all</span> the above cases, <span class="keyword">if</span> you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机最多运行24个CPU，B主机最多运行6个CPU，所以当前系统下最多可以运行的CPU个数为30，超出这个个数则会报错。</p><h1 id="参数-slots"><a href="#参数-slots" class="headerlink" title="参数  slots"></a>参数  slots</h1><p>进阶版的myhosts的编写，指定每个主机最多可以使用的CPU个数，这个CPU个数最好是小于指定主机的物理核心数，否则该设定没有意义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>指定主机A 、B中每个主机最多可以使用cpu个数均为4，其中每个主机IP（或主机名）后面的的slots的数值可以自由设定，不过只能小于等于该主机的物理核心数。</p><p>执行命令：</p><p><code>mpirun -np 4  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上。</p><p>执行命令：</p><p><code>mpirun -np 6  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，2个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 8  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示4个进程全部运行在主机A上，4个进程运行在主机B上。</p><p>执行命令：</p><p><code>mpirun -np 9  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果报错，显示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are not enough slots available in the system to satisfy the 31</span><br><span class="line">slots that were requested by the application:</span><br><span class="line"></span><br><span class="line">  /home/xxxxxx/anaconda3/bin/python</span><br><span class="line"></span><br><span class="line">Either request fewer slots for your application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line"></span><br><span class="line">A &quot;slot&quot; is the Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line"></span><br><span class="line">  1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores if not provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 if not provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line"></span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line"></span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>报错信息显示可以运行的CPU个数不够，因为A主机我们指定最多运行4个CPU，B主机最多运行4个CPU，所以当前系统下最多可以运行的CPU个数为8，超出这个个数则会报错。</p><h1 id="参数-np-："><a href="#参数-np-：" class="headerlink" title="参数 -np ："></a>参数 -np ：</h1><p>如果我们运行时不使用 -np 参数， 那么运行情节如何呢：</p><p>在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66</span><br><span class="line">192.168.11.206</span><br></pre></td></tr></table></figure><p>运行命令:</p><p>`mpirun –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>运行结果，A主机运行24个进程，B主机运行6个进程，也就是说不指定 -np参数 &#x3D;&#x3D;每个主机都是以全部的物理核心来运行进程。&#x3D;&#x3D;</p><p>如果在  myhosts 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>运行命令:</p><p><code>mpirun --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果，A主机运行4个进程，B主机运行4个进程，也就是说不指定 -np参数 和之前一样每个主机都是以全部的可以运行的CPU个数来运行进程。（因为这里在myhosts文件中使用了slots参数已经设定了A主机最多可以使用4个CPU，B主机最多可以使用4个CPU）</p><h1 id="参数-nolocal"><a href="#参数-nolocal" class="headerlink" title="参数  -nolocal"></a>参数  -nolocal</h1><p>在执行mpi命令时加入参数 -nolocal 则指定不运行当前所在主机上的CPU，具体：</p><p>假设myhosts文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>myhosts 文件指定A、B主机均只能最多使用4个CPU。</p><p>在主机A 192.168.11.66 上运行命令：</p><p>`mpirun -nolocal –machinefile myhosts &#x2F;home&#x2F;xxxxxx&#x2F;anaconda3&#x2F;bin&#x2F;python x.py`</p><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">There are notenough slots available inthe system to satisfy the 8</span><br><span class="line">slots that were requested by the application:</span><br><span class="line">/home/xxxxxx/anaconda3/bin/python</span><br><span class="line">Either request fewer slots foryour application, or make more slots</span><br><span class="line">available for use.</span><br><span class="line">A &quot;slot&quot;isthe Open MPI term for an allocatable unit where we can</span><br><span class="line">launch a process.  The number of slots available are defined by the</span><br><span class="line">environment in which Open MPI processes are run:</span><br><span class="line">1. Hostfile, via &quot;slots=N&quot; clauses (N defaults to number of</span><br><span class="line">     processor cores ifnot provided)</span><br><span class="line">  2. The --host command line parameter, via a &quot;:N&quot; suffix on the</span><br><span class="line">     hostname (N defaults to 1 ifnot provided)</span><br><span class="line">  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)</span><br><span class="line">  4. If none of a hostfile, the --host command line parameter, or an</span><br><span class="line">     RM is present, Open MPI defaults to the number of processor cores</span><br><span class="line">In all the above cases, if you want Open MPI to default to the number</span><br><span class="line">of hardware threads instead of the number of processor cores, use the</span><br><span class="line">--use-hwthread-cpus option.</span><br><span class="line">Alternatively, you can use the --oversubscribe option to ignore the</span><br><span class="line">number of available slots when deciding the number of processes to</span><br><span class="line">launch.</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>也就是说 -nolocal 不允许本地主机A参与计算，而 myhosts文件中又允许A主机参与计算，因此造成冲突。在没有使用 -np 参数的情况下是需要使用myhosts文件中指定的CPU数的最大值来运行的，但是-nolocal不允许A主机参与运行无法满足myhosts文件中的8个CPU的设定，因此报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 6  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>依旧报错误：</p><p><code>There are notenough slots available inthe system to satisfy the 6 slots that were requested by the application:</code></p><p>原因是不使用本地主机A的情况下 -np 指定需要6个CPU运行，但是myhosts中指定B主机192.168.11.206最多可以运行4个CPU，因此不满足6个CPU运行的要求报错。</p><p>我们在上面的运行语句中改进下，如下：</p><p><code> mpirun -np 4  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。四个进程全部运行在B主机192.168.11.206 上。既满足 -np 4 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><p>同理：</p><p>上面的运行语句中改进下，如下：</p><p><code> mpirun -np 2  -nolocal  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。2个进程全部运行在B主机192.168.11.206 上。既满足 -np 2 也满足 -nolocal 设定，同时也满足 myhosts中的设定。</p><h1 id="参数-–use-hwthread-cpus-与-–oversubscribe"><a href="#参数-–use-hwthread-cpus-与-–oversubscribe" class="headerlink" title="参数  –use-hwthread-cpus  与  –oversubscribe"></a>参数  –use-hwthread-cpus  与  –oversubscribe</h1><p>前面我们知道 A、B主机的CPU物理核心个数：</p><p>A电脑： 24物理核心（48逻辑核心）</p><p>B电脑：6物理核心（12逻辑核心）</p><p>&#x3D;&#x3D;-np 指定该次运行一共需要的CPU个数&#x3D;&#x3D;，-nolocal 指定不使用当前主机的CPU进行运算，myhosts中指定参与计算的各主机的最多参与计算的CPU个数。</p><p>正如我们前面所说的，myhosts文件中虽然可以指定每个主机最多可以使用的CPU个数，但是这个个数是我们人为设定的，设定的一个要求就是要小于主机的物理核心个数。如果myhosts 中slots指定的CPU数量等于主机物理核心个数那么slots本身是没有意义的，因为myhosts中不使用slots设定所能使用的最多CPU个数也是该主机的物理核心个数。</p><p>那么 myhosts 中slots的个数设定真的不能大于主机的物理核心数，其实不然。之所以我们默认要求slots个数不能大于物理核心数是因为在<strong>独占</strong>主机进行<strong>计算密集型</strong>运算时当主机上运行的进程数等于物理核心数时往往会得到最高的利用率。</p><p>一个隐藏知识，根据Intel cpu的白皮书（蓝皮书）可以看到在使用超流水线多线程运算时密集计算型计算性能可以提高30%，这就是说在Intel超流水线技术支持下，密集计算任务单主机下进程数等于逻辑核心个数其性能要&#x3D;&#x3D;超进程数等于物理核心数&#x3D;&#x3D;时的30%，不过这只是在短时间计算情景下，如果在长时间运行情况下当进程数等于逻辑核心数时计算密集型任务往往会导致CPU的散热撞到功率墙（散热墙）从而导致大幅度CPU降频，从而导致计算性能大幅下降，当然这说的是普通散热情况下，因此在进行计算密集型计算任务时我们都是默认设定进程数等于物理核心数。</p><p>也就是说，如果我们在 myhosts 文件中设定 slots 个数超过主机的物理核心数在不考虑计算性能的情况下是完全可行的。</p><p>给出此时的myhosts内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat myhosts</span><br><span class="line">192.168.11.66       slots=100</span><br><span class="line">192.168.11.206      slots=100</span><br></pre></td></tr></table></figure><p>运行语句中如下：</p><p><code>mpirun -np 200  --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功运行。共运行200个进程，其中100个进程运行在A主机192.168.11.66 上， 100个进程运行在B主机192.168.11.206 上。</p><p>由此可见使用 myhosts文件中的slots设定也是可以运行超过物理核心数的进程的。</p><p>刚才说的是在使用 –machinefile 参数 利用myhosts 文件中的设定来实现超过物理核心数的进程数量运行的，如果我们不使用 –machinefile 参数的情况下呢？？？</p><h1 id="参数-–host"><a href="#参数-–host" class="headerlink" title="参数 –host"></a>参数 –host</h1><p>执行命令：</p><p><code>mpirun -np 8  --host 192.168.11.66:4 --host 192.168.11.206:4   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行4个进程，在B主机192.168.11.206上运行4个进程，共运行8个进程。</p><p>执行命令：</p><p><code>mpirun -np 6  --host 192.168.11.206:6   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在B主机192.168.11.206上运行6个进程，共运行6个进程。</p><p>执行命令：</p><p><code>mpirun -np 200  --host 192.168.11.66:100 --host 192.168.11.206:100   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66主机上运行100个进程，在B主机192.168.11.206上运行100个进程，共运行200个进程。</p><p>执行命令：</p><p><code>mpirun -np 200 --host 192.168.11.206:200   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在B主机192.168.11.206上运行200个进程，共运行200个进程。</p><p>当然上面的都是在分布式的环境下运行的（ 分布式环境下是指使用 –host 参数）。</p><p>如果不使用 –host 参数，在单机环境下如何实现超过物理核心数的进程数运行呢？？？</p><p>如：</p><p>执行命令：</p><p><code>mpirun -np 48   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>命令的含义是在A主机192.168.11.66上运行48个进程，而A主机的物理核心数为24，因此报错。</p><p>There are notenough slots available inthe system to satisfy the 48<br>slots that were requested by the application:</p><p>这时改用命令：（加入参数 –use-hwthread-cpus ）</p><p>--use-hwthread-cpus 参数的含义是允许当前主机运行的进程最大数为逻辑核心数而不是物理核心数。</p><p><code>mpirun -np 48 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在在A主机192.168.11.66上运行48个进程，A主机为当前命令执行时所在的主机，其逻辑核心数为48。</p><p>改命令为：</p><p><code>mpirun -np 49 --use-hwthread-cpus  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行失败，因为 –use-hwthread-cpus 参数只能设定最多运行进程数为逻辑核心数，因此超过48后报错（A主机逻辑核心数为48）。</p><p>这时改用 参数 –oversubscribe ：</p><p>--oversubscribe 参数的含义就是不对进程数设限制，也就是说进程数可以随便设置。</p><p>执行命令如下：</p><p><code>mpirun -np 200  --oversubscribe  /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>成功在A主机192.168.11.66上运行了200个进程。</p><h1 id="附加内容："><a href="#附加内容：" class="headerlink" title="附加内容："></a>附加内容：</h1><p>在执行mpi程序时rank0进程是在哪个主机上呢？？？</p><p>（rank0进程就是mpi程序运行后rank排名号为0号的进程）</p><p>在主机A 192.168.11.66 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在A主机 192.168.11.66上。</p><p>同理：</p><p>在主机B 192.168.11.206 上：</p><p>myhosts文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.66       slots=4</span><br><span class="line">192.168.11.206      slots=4</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><code>mpirun -np 8   --machinefile myhosts   /home/xxxxxx/anaconda3/bin/python x.py</code></p><p>运行结果显示，rank0进程运行在B主机 192.168.11.206上。</p><p>由上面的运行情况我们可以知道 rank0 进程一般都是运行在启动mpi程序并使用CPU运行进程的主机上（需要排除使用参数 -nolocal 的情况，该种情况启动mpi程序的主机是不使用CPU参与计算的，因此rank0进程此时是不在启动mpi程序的主机上的）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mpirun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-basic</title>
      <link href="/2023/04/20/vscode-basic/"/>
      <url>/2023/04/20/vscode-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>打开<a href="https://code.visualstudio.com/">Vscode</a> 官网直接下载即可</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ol><li><p>Python</p><p>Python为VSCode添加了对Python的语言支持，包括 IntelliSense 和Debugging等功能</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145247297.png" alt="image-20230420145247297"></p><ol start="2"><li><p>Jupyter</p><p>  Jupyter为VSCode添加了对Jupyter Notebook的功能支持</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145530009.png" alt="image-20230420145530009"></p><ol start="3"><li><p>Code Runner</p><p>Code Runner用于直接运行多种语言的代码片段或文件</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145551529.png" alt="image-20230420145551529"></p><ol start="4"><li><p>Better Comments</p><p>Better Comments为代码注释提供各种特定类型注释的高亮。</p></li></ol><p> <img src="/2023/04/20/vscode-basic/image-20230420145609253.png" alt="image-20230420145609253"></p><ol start="5"><li><p>Bracket Pair Colorizer</p><p>给匹配的括号着色</p></li><li><p>Indent-Rainbow</p><p>让缩进带有颜色</p></li><li><p>Path Intellisense</p><p>自动完成文件名</p></li><li><p>Prettier - Code formatter</p><p>更优雅的代码格式化,vscode 里比较优秀的一个格式化插件</p></li><li><p>matlab插件</p><p>支持自动补全、跳转定义、变量重命名 </p></li><li><p>Remote-SSH</p></li></ol><p><img src="/2023/04/20/vscode-basic/image-20230420145707498.png" alt="image-20230420145707498"></p><ol start="11"><li><p>Markdown Preview Enhanced（markdown 预览增强）</p></li><li><p>GitHub Pull Requests and Issues</p><p>自动识别仓库变动，一键push和pull，特别方便</p><p><img src="/2023/04/20/vscode-basic/image-20230423173040299.png" alt="image-20230423173040299"></p></li><li><p>WD-TabNine</p><p>非常强大的代码自动补全工具</p></li></ol><h1 id="Remote-SSH连接"><a href="#Remote-SSH连接" class="headerlink" title="Remote-SSH连接"></a>Remote-SSH连接</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装Remote-SSHR之后，点击界面左下角的打开远程窗口</p><p><img src="/2023/04/20/vscode-basic/image-20230420145744807.png" alt="image-20230420145744807"></p><p>选择Connect to Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145758242.png" alt="image-20230420145758242"></p><p>选择Add New SSH Host</p><p><img src="/2023/04/20/vscode-basic/image-20230420145807767.png" alt="image-20230420145807767"></p><p>输入对应的用户名和远程IP地址</p><p><img src="/2023/04/20/vscode-basic/image-20230420145813675.png" alt="image-20230420145813675"></p><p>在弹出的设置配置文件路径，选择第一项</p><p><img src="/2023/04/20/vscode-basic/image-20230420145819225.png" alt="image-20230420145819225"></p><p>界面右下角显示Host added!</p><p><img src="/2023/04/20/vscode-basic/image-20230420145824770.png" alt="image-20230420145824770"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>添加host成功之后，再点击左下角的打开远程连接窗口，</p><p>  <img src="/2023/04/20/vscode-basic/image-20230420145829467.png" alt="image-20230420145829467"></p><p>就会出现刚刚配置好的host，点击，输入密码，就可以成功登录了</p><p> <img src="/2023/04/20/vscode-basic/image-20230420145837776.png" alt="image-20230420145837776"></p><h2 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h2><p>登录成功后，为了避免每次输入密码，在linux服务器上添加公钥（参考添加公钥到github）;</p><p>在远程终端上</p><p>先定位目录<br><code> cd .ssh</code></p><p>再看看有没有authorized_keys文件：<br> <code>ls</code></p><p>然后编辑它<br><code> vim authorized_keys</code></p><p>然后按i进入编辑模式<br> 然后把本机 后缀.pub文件（比如id_rsa.pub）的内容粘贴上去：<br> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPsqZlc1lASXIwrOSpyyghF+U 一大串</p><p>最后 按ESC 然后输入:wq （写入内容并quit退出）<br> 然后关闭vscode窗口自动断开链接，再按 第3步 直接点击 然后直接连接上并成功登录！</p><h1 id="使用远程服务器上的jypyter"><a href="#使用远程服务器上的jypyter" class="headerlink" title="使用远程服务器上的jypyter"></a>使用远程服务器上的jypyter</h1><h2 id="启动jupyper-服务器"><a href="#启动jupyper-服务器" class="headerlink" title="启动jupyper 服务器"></a>启动jupyper 服务器</h2><p>在终端激活对应的conda 虚拟环境之后，输入jupyter notebook，启动jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145849003.png" alt="image-20230420145849003"></p><p>复制下面的地址，两个都可以</p><p><img src="/2023/04/20/vscode-basic/image-20230420145854628.png" alt="image-20230420145854628"></p><h2 id="vscode中连接远程jupyter"><a href="#vscode中连接远程jupyter" class="headerlink" title="vscode中连接远程jupyter"></a>vscode中连接远程jupyter</h2><p>安装juyter拓展后，按快捷键打开输入框，输入jupyter以后就可以看到以下提示，选择为连接指定jupyter服务器</p><p><img src="/2023/04/20/vscode-basic/image-20230420145901403.png" alt="image-20230420145901403"></p><p>之后进入以下界面，需要输入刚刚已启动的jupyter notebook的URL连接，如上的两个链接，复制输入框中按回车就可以连接服务器上的jupyter</p><p><img src="/2023/04/20/vscode-basic/image-20230420145907727.png" alt="image-20230420145907727"></p><p>此时就可以选择新建或打开远程服务器上的ipynb文件，可能会提示要为远程服务器安装python拓展，确认安装即可。</p><h2 id="切换虚拟环境"><a href="#切换虚拟环境" class="headerlink" title="切换虚拟环境"></a>切换虚拟环境</h2><p>服务器上配置有多个 <a href="https://so.csdn.net/so/search?q=conda&spm=1001.2101.3001.7020">conda</a> 虚拟环境，如果每次启动jupyter之前需要激活对应的虚拟环境，后续就不方便切换，</p><p>使用nb_conda_kernels 添加所有环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate base   # could be also some other environment</span><br><span class="line"></span><br><span class="line">conda install nb_conda_kernels</span><br><span class="line"></span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>安装好后，打开 jupyter notebook 就会显示所有的 conda 环境</p><p><img src="/2023/04/20/vscode-basic/image-20230420145917965.png" alt="image-20230420145917965"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
